var tipuesearch = {"pages":[{"title":" fhash API Reference ","text":"fhash API Reference fhash fpm package implementing a hash table with support for generic keys and values. fpm usage To use fhash within your fpm project, add the following to your package manifest file ( fpm.toml ): [dependencies] fhash = { git = \"https://github.com/LKedward/fhash.git\" } Simple example: scalar intrinsics The package provides a fhash_tbl_t type with set and get methods for storing and retrieving key-value pairs.\nThe fhash_key interface (aliased to key below) is used to define a valid key from different inputs. program fhash_demo1 use fhash , only : fhash_tbl_t , key => fhash_key implicit none type ( fhash_tbl_t ) :: tbl integer :: val call tbl % set ( key ( 'my_key_1' ), value = 10 ) call tbl % set ( key ( 'my_key_2' ), value = 1.0 ) call tbl % set ( key ( 123456 ), value = 'a string value' ) call tbl % set ( key ([ 1 , 2 , 3 , 4 , 5 ]), value = . false .) call tbl % get ( key ( 'my_key_1' ), val ) end program fhash_demo1 See the Quickstart Guide for an explanation of this example and the API methods used. Advanced usage More table methods Storing custom derived types as values Using custom derived types as keys See https://lkedward.github.io/fhash/ for the full API documentation. Developer Info L. Kedward","tags":"home","loc":"index.html"},{"title":"fhash_node_t – fhash API Reference ","text":"type, public :: fhash_node_t Node type for hash table singly linked list Contents Variables key value next Components Type Visibility Attributes Name Initial class( fhash_key_t ), public, allocatable :: key type( fhash_container_t ), public :: value type( fhash_node_t ), public, pointer :: next => NULL()","tags":"","loc":"type/fhash_node_t.html"},{"title":"fhash_container_t – fhash API Reference ","text":"type, public :: fhash_container_t Generic container for scalar and 1D data Contents Variables scalar_data scalar_ptr Type-Bound Procedures allocated get get_ptr Components Type Visibility Attributes Name Initial class(*), public, allocatable :: scalar_data class(*), public, pointer :: scalar_ptr => NULL() Type-Bound Procedures procedure, public,  :: allocated => fhash_container_allocated private  function fhash_container_allocated(container) result(alloc) Helper to determine if container contains anything Arguments Type Intent Optional Attributes Name class( fhash_container_t ), intent(in) :: container Return Value logical procedure, public,  :: get => fhash_container_get_scalar private  subroutine fhash_container_get_scalar(container, i32, i64, r32, r64, char, bool, raw, match, type_string) Helper to return container value as intrinsic type Arguments Type Intent Optional Attributes Name class( fhash_container_t ), intent(in), target :: container integer(kind=int32), intent(out), optional :: i32 integer(kind=int64), intent(out), optional :: i64 real(kind=sp), intent(out), optional :: r32 real(kind=dp), intent(out), optional :: r64 character(len=:), intent(out), optional, allocatable :: char logical, intent(out), optional :: bool class(*), intent(out), optional, allocatable :: raw logical, intent(out), optional :: match character(len=:), intent(out), optional, allocatable :: type_string procedure, public,  :: get_ptr => fhash_container_get_scalar_ptr private  subroutine fhash_container_get_scalar_ptr(container, i32, i64, r32, r64, char, bool, raw, match, type_string) Helper to return pointer to container value as intrinsic type Arguments Type Intent Optional Attributes Name class( fhash_container_t ), intent(in), target :: container integer(kind=int32), intent(out), optional, pointer :: i32 integer(kind=int64), intent(out), optional, pointer :: i64 real(kind=sp), intent(out), optional, pointer :: r32 real(kind=dp), intent(out), optional, pointer :: r64 character(len=:), intent(out), optional, pointer :: char logical, intent(out), optional, pointer :: bool class(*), intent(out), optional, pointer :: raw logical, intent(out), optional :: match character(len=:), intent(out), optional, allocatable :: type_string","tags":"","loc":"type/fhash_container_t.html"},{"title":"fhash_iter_t – fhash API Reference ","text":"type, public :: fhash_iter_t Iterator type for iterating over hash table items Contents Variables tbl bucket depth Constructor fhash_iter_t Type-Bound Procedures next reset Components Type Visibility Attributes Name Initial type( fhash_tbl_t ), public, pointer :: tbl => NULL() integer, public :: bucket = 1 integer, public :: depth = 1 Constructor public        interface fhash_iter_t private  function fhash_iter_init(tbl) result(iter) Initialise fhash iterator Arguments Type Intent Optional Attributes Name type( fhash_tbl_t ), intent(in), target :: tbl Return Value type( fhash_iter_t ) Type-Bound Procedures procedure, public,  :: next => fhash_iter_next private  function fhash_iter_next(iter, key, data) result(found) Return next item from iterator Arguments Type Intent Optional Attributes Name class( fhash_iter_t ), intent(inout) :: iter class( fhash_key_t ), intent(out), allocatable :: key class(*), intent(out), allocatable :: data Return Value logical procedure, public,  :: reset => fhash_iter_reset private  subroutine fhash_iter_reset(iter) Reset iterator to beginning Arguments Type Intent Optional Attributes Name class( fhash_iter_t ), intent(inout) :: iter","tags":"","loc":"type/fhash_iter_t.html"},{"title":"fhash_tbl_t – fhash API Reference ","text":"type, public :: fhash_tbl_t Contents Variables buckets Finalization Procedures fhash_tbl_cleanup Type-Bound Procedures allocate unset check_key stats fhash_tbl_set_scalar set fhash_tbl_set_scalar_ptr set_ptr fhash_tbl_get_int64 fhash_tbl_get_int32 fhash_tbl_get_double fhash_tbl_get_float fhash_tbl_get_logical fhash_tbl_get_char fhash_tbl_get_raw fhash_tbl_get_data get get get get get_raw fhash_tbl_get_int64_ptr fhash_tbl_get_int32_ptr fhash_tbl_get_double_ptr fhash_tbl_get_float_ptr fhash_tbl_get_logical_ptr fhash_tbl_get_char_ptr fhash_tbl_get_raw_ptr get_ptr get_ptr get_ptr get_raw_ptr Components Type Visibility Attributes Name Initial type( fhash_node_t ), public, allocatable :: buckets (:) Finalization Procedures final :: fhash_tbl_cleanup private  subroutine fhash_tbl_cleanup(tbl) Finalizer for fhash_tbl_t Arguments Type Intent Optional Attributes Name type( fhash_tbl_t ), intent(inout) :: tbl Table object to allocate Type-Bound Procedures procedure, public,  :: allocate => fhash_tbl_allocate private  subroutine fhash_tbl_allocate(tbl, size) Allocate hash table Arguments Type Intent Optional Attributes Name class( fhash_tbl_t ), intent(inout) :: tbl Table object to allocate integer, intent(in), optional :: size Number of buckets in hash table\nIf ommited, tbl is allocated with FHASH_DEFAULT_ALLOCATION procedure, public,  :: unset => fhash_tbl_unset private  subroutine fhash_tbl_unset(tbl, key, stat) Unset a value in the table Arguments Type Intent Optional Attributes Name class( fhash_tbl_t ), intent(inout) :: tbl Hash table object class( fhash_key_t ), intent(in) :: key Key to remove integer, intent(out), optional :: stat Status flag. Zero if successful.\nUnsuccessful: FHASH_EMPTY_TABLE | FHASH_KEY_NOT_FOUND procedure, public,  :: check_key => fhash_tbl_check_key private  subroutine fhash_tbl_check_key(tbl, key, stat) Check if key exists in table Arguments Type Intent Optional Attributes Name class( fhash_tbl_t ), intent(in) :: tbl Hash table object class( fhash_key_t ), intent(in) :: key Key to retrieve integer, intent(out) :: stat Status flag. Zero if key is found.\nUnsuccessful: FHASH_EMPTY_TABLE | FHASH_KEY_NOT_FOUND procedure, public,  :: stats => fhash_tbl_stats private  subroutine fhash_tbl_stats(tbl, num_buckets, num_items, num_collisions, max_depth) Get stats about the hash table Arguments Type Intent Optional Attributes Name class( fhash_tbl_t ), intent(in) :: tbl Hash table object integer, intent(out), optional :: num_buckets Number of buckets allocated in table integer, intent(out), optional :: num_items Number of key-value pairs stored in table integer, intent(out), optional :: num_collisions Number of hash collisions integer, intent(out), optional :: max_depth Maximum depth of bucket in table procedure, public,  :: fhash_tbl_set_scalar private  subroutine fhash_tbl_set_scalar(tbl, key, value, pointer) Set/update a polymorphic scalar value in the table tbl is allocated with default size if not already allocated Arguments Type Intent Optional Attributes Name class( fhash_tbl_t ), intent(inout) :: tbl Hash table object class( fhash_key_t ), intent(in) :: key Key to set/update class(*), intent(in), target :: value Value for key logical, intent(in), optional :: pointer If .true., store a pointer to value instead of copying generic, public,  :: set => fhash_tbl_set_scalar private  subroutine fhash_tbl_set_scalar(tbl, key, value, pointer) Set/update a polymorphic scalar value in the table tbl is allocated with default size if not already allocated Arguments Type Intent Optional Attributes Name class( fhash_tbl_t ), intent(inout) :: tbl Hash table object class( fhash_key_t ), intent(in) :: key Key to set/update class(*), intent(in), target :: value Value for key logical, intent(in), optional :: pointer If .true., store a pointer to value instead of copying procedure, public,  :: fhash_tbl_set_scalar_ptr private  subroutine fhash_tbl_set_scalar_ptr(tbl, key, value) Get wrapper routine for generic 'set_ptr' tbl is allocated with default size if not already allocated Arguments Type Intent Optional Attributes Name class( fhash_tbl_t ), intent(inout) :: tbl Hash table object class( fhash_key_t ), intent(in) :: key Key to set/update class(*), intent(in), target :: value Value for key generic, public,  :: set_ptr => fhash_tbl_set_scalar_ptr private  subroutine fhash_tbl_set_scalar_ptr(tbl, key, value) Get wrapper routine for generic 'set_ptr' tbl is allocated with default size if not already allocated Arguments Type Intent Optional Attributes Name class( fhash_tbl_t ), intent(inout) :: tbl Hash table object class( fhash_key_t ), intent(in) :: key Key to set/update class(*), intent(in), target :: value Value for key procedure, public,  :: fhash_tbl_get_int64 private  subroutine fhash_tbl_get_int64(tbl, key, value, stat) Get wrapper to directly retrieve a scalar int64 value Arguments Type Intent Optional Attributes Name class( fhash_tbl_t ), intent(in) :: tbl Hash table object class( fhash_key_t ), intent(in) :: key Key to retrieve integer(kind=int64), intent(out) :: value Output value integer, intent(out), optional :: stat Status flag. Zero if successful. procedure, public,  :: fhash_tbl_get_int32 private  subroutine fhash_tbl_get_int32(tbl, key, value, stat) Get wrapper to directly retrieve a scalar int32 value Arguments Type Intent Optional Attributes Name class( fhash_tbl_t ), intent(in) :: tbl Hash table object class( fhash_key_t ), intent(in) :: key Key to retrieve integer(kind=int32), intent(out) :: value Output value integer, intent(out), optional :: stat Status flag. Zero if successful. procedure, public,  :: fhash_tbl_get_double private  subroutine fhash_tbl_get_double(tbl, key, value, stat) Get wrapper to directly retrieve a scalar double value Arguments Type Intent Optional Attributes Name class( fhash_tbl_t ), intent(in) :: tbl Hash table object class( fhash_key_t ), intent(in) :: key Key to retrieve real(kind=dp), intent(out) :: value Output value integer, intent(out), optional :: stat Status flag. Zero if successful. procedure, public,  :: fhash_tbl_get_float private  subroutine fhash_tbl_get_float(tbl, key, value, stat) Get wrapper to directly retrieve a scalar float value Arguments Type Intent Optional Attributes Name class( fhash_tbl_t ), intent(in) :: tbl Hash table object class( fhash_key_t ), intent(in) :: key Key to retrieve real(kind=sp), intent(out) :: value Output value integer, intent(out), optional :: stat Status flag. Zero if successful. procedure, public,  :: fhash_tbl_get_logical private  subroutine fhash_tbl_get_logical(tbl, key, value, stat) Get wrapper to directly retrieve a scalar logical value Arguments Type Intent Optional Attributes Name class( fhash_tbl_t ), intent(in) :: tbl Hash table object class( fhash_key_t ), intent(in) :: key Key to retrieve logical, intent(out) :: value Output value integer, intent(out), optional :: stat Status flag. Zero if successful. procedure, public,  :: fhash_tbl_get_char private  subroutine fhash_tbl_get_char(tbl, key, value, stat) Get wrapper to directly retrieve a scalar character value Arguments Type Intent Optional Attributes Name class( fhash_tbl_t ), intent(in) :: tbl Hash table object class( fhash_key_t ), intent(in) :: key Key to retrieve character(len=:), intent(out), allocatable :: value Output value integer, intent(out), optional :: stat Status flag. Zero if successful. procedure, public,  :: fhash_tbl_get_raw private  subroutine fhash_tbl_get_raw(tbl, key, value, stat) Get wrapper to directly retrieve underlying polymorhpic scalar value Arguments Type Intent Optional Attributes Name class( fhash_tbl_t ), intent(in) :: tbl Hash table object class( fhash_key_t ), intent(in) :: key Key to retrieve class(*), intent(out), allocatable :: value Output value integer, intent(out), optional :: stat Status flag. Zero if successful. procedure, public,  :: fhash_tbl_get_data private  subroutine fhash_tbl_get_data(tbl, key, data, stat) Retrieve data container from the hash table Arguments Type Intent Optional Attributes Name class( fhash_tbl_t ), intent(in) :: tbl Hash table object class( fhash_key_t ), intent(in) :: key Key to retrieve type( fhash_container_t ), pointer :: data Copy of value retrieved for key integer, intent(out), optional :: stat Status flag. Zero if successful.\nUnsuccessful: FHASH_EMPTY_TABLE | FHASH_KEY_NOT_FOUND generic, public,  :: get => fhash_tbl_get_int32 , fhash_tbl_get_int64 private  subroutine fhash_tbl_get_int32(tbl, key, value, stat) Get wrapper to directly retrieve a scalar int32 value Arguments Type Intent Optional Attributes Name class( fhash_tbl_t ), intent(in) :: tbl Hash table object class( fhash_key_t ), intent(in) :: key Key to retrieve integer(kind=int32), intent(out) :: value Output value integer, intent(out), optional :: stat Status flag. Zero if successful. private  subroutine fhash_tbl_get_int64(tbl, key, value, stat) Get wrapper to directly retrieve a scalar int64 value Arguments Type Intent Optional Attributes Name class( fhash_tbl_t ), intent(in) :: tbl Hash table object class( fhash_key_t ), intent(in) :: key Key to retrieve integer(kind=int64), intent(out) :: value Output value integer, intent(out), optional :: stat Status flag. Zero if successful. generic, public,  :: get => fhash_tbl_get_float , fhash_tbl_get_double private  subroutine fhash_tbl_get_float(tbl, key, value, stat) Get wrapper to directly retrieve a scalar float value Arguments Type Intent Optional Attributes Name class( fhash_tbl_t ), intent(in) :: tbl Hash table object class( fhash_key_t ), intent(in) :: key Key to retrieve real(kind=sp), intent(out) :: value Output value integer, intent(out), optional :: stat Status flag. Zero if successful. private  subroutine fhash_tbl_get_double(tbl, key, value, stat) Get wrapper to directly retrieve a scalar double value Arguments Type Intent Optional Attributes Name class( fhash_tbl_t ), intent(in) :: tbl Hash table object class( fhash_key_t ), intent(in) :: key Key to retrieve real(kind=dp), intent(out) :: value Output value integer, intent(out), optional :: stat Status flag. Zero if successful. generic, public,  :: get => fhash_tbl_get_char , fhash_tbl_get_logical private  subroutine fhash_tbl_get_char(tbl, key, value, stat) Get wrapper to directly retrieve a scalar character value Arguments Type Intent Optional Attributes Name class( fhash_tbl_t ), intent(in) :: tbl Hash table object class( fhash_key_t ), intent(in) :: key Key to retrieve character(len=:), intent(out), allocatable :: value Output value integer, intent(out), optional :: stat Status flag. Zero if successful. private  subroutine fhash_tbl_get_logical(tbl, key, value, stat) Get wrapper to directly retrieve a scalar logical value Arguments Type Intent Optional Attributes Name class( fhash_tbl_t ), intent(in) :: tbl Hash table object class( fhash_key_t ), intent(in) :: key Key to retrieve logical, intent(out) :: value Output value integer, intent(out), optional :: stat Status flag. Zero if successful. generic, public,  :: get => fhash_tbl_get_data private  subroutine fhash_tbl_get_data(tbl, key, data, stat) Retrieve data container from the hash table Arguments Type Intent Optional Attributes Name class( fhash_tbl_t ), intent(in) :: tbl Hash table object class( fhash_key_t ), intent(in) :: key Key to retrieve type( fhash_container_t ), pointer :: data Copy of value retrieved for key integer, intent(out), optional :: stat Status flag. Zero if successful.\nUnsuccessful: FHASH_EMPTY_TABLE | FHASH_KEY_NOT_FOUND generic, public,  :: get_raw => fhash_tbl_get_raw private  subroutine fhash_tbl_get_raw(tbl, key, value, stat) Get wrapper to directly retrieve underlying polymorhpic scalar value Arguments Type Intent Optional Attributes Name class( fhash_tbl_t ), intent(in) :: tbl Hash table object class( fhash_key_t ), intent(in) :: key Key to retrieve class(*), intent(out), allocatable :: value Output value integer, intent(out), optional :: stat Status flag. Zero if successful. procedure, public,  :: fhash_tbl_get_int64_ptr private  subroutine fhash_tbl_get_int64_ptr(tbl, key, value, stat) Get wrapper to directly retrieve a scalar int64 value Arguments Type Intent Optional Attributes Name class( fhash_tbl_t ), intent(in) :: tbl Hash table object class( fhash_key_t ), intent(in) :: key Key to retrieve integer(kind=int64), intent(out), pointer :: value Output value pointer integer, intent(out), optional :: stat Status flag. Zero if successful. procedure, public,  :: fhash_tbl_get_int32_ptr private  subroutine fhash_tbl_get_int32_ptr(tbl, key, value, stat) Get wrapper to directly retrieve a scalar int32 value Arguments Type Intent Optional Attributes Name class( fhash_tbl_t ), intent(in) :: tbl Hash table object class( fhash_key_t ), intent(in) :: key Key to retrieve integer(kind=int32), intent(out), pointer :: value Output value pointer integer, intent(out), optional :: stat Status flag. Zero if successful. procedure, public,  :: fhash_tbl_get_double_ptr private  subroutine fhash_tbl_get_double_ptr(tbl, key, value, stat) Get wrapper to directly retrieve a scalar double value Arguments Type Intent Optional Attributes Name class( fhash_tbl_t ), intent(in) :: tbl Hash table object class( fhash_key_t ), intent(in) :: key Key to retrieve real(kind=dp), intent(out), pointer :: value Output value pointer integer, intent(out), optional :: stat Status flag. Zero if successful. procedure, public,  :: fhash_tbl_get_float_ptr private  subroutine fhash_tbl_get_float_ptr(tbl, key, value, stat) Get wrapper to directly retrieve a scalar float value Arguments Type Intent Optional Attributes Name class( fhash_tbl_t ), intent(in) :: tbl Hash table object class( fhash_key_t ), intent(in) :: key Key to retrieve real(kind=sp), intent(out), pointer :: value Output value pointer integer, intent(out), optional :: stat Status flag. Zero if successful. procedure, public,  :: fhash_tbl_get_logical_ptr private  subroutine fhash_tbl_get_logical_ptr(tbl, key, value, stat) Get wrapper to directly retrieve a scalar logical value Arguments Type Intent Optional Attributes Name class( fhash_tbl_t ), intent(in) :: tbl Hash table object class( fhash_key_t ), intent(in) :: key Key to retrieve logical, intent(out), pointer :: value Output value pointer integer, intent(out), optional :: stat Status flag. Zero if successful. procedure, public,  :: fhash_tbl_get_char_ptr private  subroutine fhash_tbl_get_char_ptr(tbl, key, value, stat) Get wrapper to directly retrieve a scalar character value Arguments Type Intent Optional Attributes Name class( fhash_tbl_t ), intent(in) :: tbl Hash table object class( fhash_key_t ), intent(in) :: key Key to retrieve character(len=:), intent(out), pointer :: value Output value pointer integer, intent(out), optional :: stat Status flag. Zero if successful. procedure, public,  :: fhash_tbl_get_raw_ptr private  subroutine fhash_tbl_get_raw_ptr(tbl, key, value, stat) Get wrapper to directly retrieve underlying polymorhpic scalar value Arguments Type Intent Optional Attributes Name class( fhash_tbl_t ), intent(in) :: tbl Hash table object class( fhash_key_t ), intent(in) :: key Key to retrieve class(*), intent(out), pointer :: value Output value integer, intent(out), optional :: stat Status flag. Zero if successful. generic, public,  :: get_ptr => fhash_tbl_get_int32_ptr , fhash_tbl_get_int64_ptr private  subroutine fhash_tbl_get_int32_ptr(tbl, key, value, stat) Get wrapper to directly retrieve a scalar int32 value Arguments Type Intent Optional Attributes Name class( fhash_tbl_t ), intent(in) :: tbl Hash table object class( fhash_key_t ), intent(in) :: key Key to retrieve integer(kind=int32), intent(out), pointer :: value Output value pointer integer, intent(out), optional :: stat Status flag. Zero if successful. private  subroutine fhash_tbl_get_int64_ptr(tbl, key, value, stat) Get wrapper to directly retrieve a scalar int64 value Arguments Type Intent Optional Attributes Name class( fhash_tbl_t ), intent(in) :: tbl Hash table object class( fhash_key_t ), intent(in) :: key Key to retrieve integer(kind=int64), intent(out), pointer :: value Output value pointer integer, intent(out), optional :: stat Status flag. Zero if successful. generic, public,  :: get_ptr => fhash_tbl_get_float_ptr , fhash_tbl_get_double_ptr private  subroutine fhash_tbl_get_float_ptr(tbl, key, value, stat) Get wrapper to directly retrieve a scalar float value Arguments Type Intent Optional Attributes Name class( fhash_tbl_t ), intent(in) :: tbl Hash table object class( fhash_key_t ), intent(in) :: key Key to retrieve real(kind=sp), intent(out), pointer :: value Output value pointer integer, intent(out), optional :: stat Status flag. Zero if successful. private  subroutine fhash_tbl_get_double_ptr(tbl, key, value, stat) Get wrapper to directly retrieve a scalar double value Arguments Type Intent Optional Attributes Name class( fhash_tbl_t ), intent(in) :: tbl Hash table object class( fhash_key_t ), intent(in) :: key Key to retrieve real(kind=dp), intent(out), pointer :: value Output value pointer integer, intent(out), optional :: stat Status flag. Zero if successful. generic, public,  :: get_ptr => fhash_tbl_get_char_ptr , fhash_tbl_get_logical_ptr private  subroutine fhash_tbl_get_char_ptr(tbl, key, value, stat) Get wrapper to directly retrieve a scalar character value Arguments Type Intent Optional Attributes Name class( fhash_tbl_t ), intent(in) :: tbl Hash table object class( fhash_key_t ), intent(in) :: key Key to retrieve character(len=:), intent(out), pointer :: value Output value pointer integer, intent(out), optional :: stat Status flag. Zero if successful. private  subroutine fhash_tbl_get_logical_ptr(tbl, key, value, stat) Get wrapper to directly retrieve a scalar logical value Arguments Type Intent Optional Attributes Name class( fhash_tbl_t ), intent(in) :: tbl Hash table object class( fhash_key_t ), intent(in) :: key Key to retrieve logical, intent(out), pointer :: value Output value pointer integer, intent(out), optional :: stat Status flag. Zero if successful. generic, public,  :: get_raw_ptr => fhash_tbl_get_raw_ptr private  subroutine fhash_tbl_get_raw_ptr(tbl, key, value, stat) Get wrapper to directly retrieve underlying polymorhpic scalar value Arguments Type Intent Optional Attributes Name class( fhash_tbl_t ), intent(in) :: tbl Hash table object class( fhash_key_t ), intent(in) :: key Key to retrieve class(*), intent(out), pointer :: value Output value integer, intent(out), optional :: stat Status flag. Zero if successful.","tags":"","loc":"type/fhash_tbl_t.html"},{"title":"fhash_key_char_t – fhash API Reference ","text":"type, public, extends( fhash_key_t ) :: fhash_key_char_t Hash table key container Contents Type-Bound Procedures operator(==) hash equals to_string Type-Bound Procedures generic, public :: operator(==) => equals private pure function key_equal_int64_1d(key1, key2) result(keys_equal) Check if two keys are equal Arguments Type Intent Optional Attributes Name class( fhash_key_int64_1d_t ), intent(in) :: key1 class( fhash_key_t ), intent(in) :: key2 Return Value logical procedure, public, pass :: hash => key_hash_char private pure function key_hash_char(key) result(hash) Generate hash of key Arguments Type Intent Optional Attributes Name class( fhash_key_char_t ), intent(in) :: key Return Value integer(kind=int64) procedure, public, pass :: equals => key_equal_char private pure function key_equal_char(key1, key2) result(keys_equal) Check if two keys are equal Arguments Type Intent Optional Attributes Name class( fhash_key_char_t ), intent(in) :: key1 class( fhash_key_t ), intent(in) :: key2 Return Value logical procedure, public, pass :: to_string => key_char_to_string private  function key_char_to_string(key) result(str) Generate string representation of hash Arguments Type Intent Optional Attributes Name class( fhash_key_char_t ), intent(in) :: key Return Value character(len=:), allocatable","tags":"","loc":"type/fhash_key_char_t.html"},{"title":"fhash_key_t – fhash API Reference ","text":"type, public, abstract :: fhash_key_t Abstract base type for defining hash keys Contents Type-Bound Procedures hash equals to_string operator(==) Type-Bound Procedures procedure(hash_proc), public, deferred :: hash pure function hash_proc(key) result(hash) Prototype Arguments Type Intent Optional Attributes Name class( fhash_key_t ), intent(in) :: key Return Value integer(kind=int64) procedure(equality_proc), public, deferred :: equals pure function equality_proc(key1, key2) result(keys_equal) Prototype Arguments Type Intent Optional Attributes Name class( fhash_key_t ), intent(in) :: key1 class( fhash_key_t ), intent(in) :: key2 Return Value logical procedure(to_string_proc), public, deferred :: to_string function to_string_proc(key) result(str) Prototype Arguments Type Intent Optional Attributes Name class( fhash_key_t ), intent(in) :: key Return Value character(len=:), allocatable generic, public :: operator(==) => equals private pure function key_equal_int64_1d(key1, key2) result(keys_equal) Check if two keys are equal Arguments Type Intent Optional Attributes Name class( fhash_key_int64_1d_t ), intent(in) :: key1 class( fhash_key_t ), intent(in) :: key2 Return Value logical","tags":"","loc":"type/fhash_key_t.html"},{"title":"fhash_key_int64_1d_t – fhash API Reference ","text":"type, public, extends( fhash_key_t ) :: fhash_key_int64_1d_t Hash table key container Contents Type-Bound Procedures operator(==) hash equals to_string Type-Bound Procedures generic, public :: operator(==) => equals private pure function key_equal_int64_1d(key1, key2) result(keys_equal) Check if two keys are equal Arguments Type Intent Optional Attributes Name class( fhash_key_int64_1d_t ), intent(in) :: key1 class( fhash_key_t ), intent(in) :: key2 Return Value logical procedure, public, pass :: hash => key_hash_int64_1d private pure function key_hash_int64_1d(key) result(hash) Generate hash of key Arguments Type Intent Optional Attributes Name class( fhash_key_int64_1d_t ), intent(in) :: key Return Value integer(kind=int64) procedure, public, pass :: equals => key_equal_int64_1d private pure function key_equal_int64_1d(key1, key2) result(keys_equal) Check if two keys are equal Arguments Type Intent Optional Attributes Name class( fhash_key_int64_1d_t ), intent(in) :: key1 class( fhash_key_t ), intent(in) :: key2 Return Value logical procedure, public, pass :: to_string => key_int64_1d_to_string private pure function key_int64_1d_to_string(key) result(str) Generate string representation of hash Arguments Type Intent Optional Attributes Name class( fhash_key_int64_1d_t ), intent(in) :: key Return Value character(len=:), allocatable","tags":"","loc":"type/fhash_key_int64_1d_t.html"},{"title":"fhash_key_int64_t – fhash API Reference ","text":"type, public, extends( fhash_key_t ) :: fhash_key_int64_t Hash table key container Contents Type-Bound Procedures operator(==) hash equals to_string Type-Bound Procedures generic, public :: operator(==) => equals private pure function key_equal_int64_1d(key1, key2) result(keys_equal) Check if two keys are equal Arguments Type Intent Optional Attributes Name class( fhash_key_int64_1d_t ), intent(in) :: key1 class( fhash_key_t ), intent(in) :: key2 Return Value logical procedure, public, pass :: hash => key_hash_int64 private pure function key_hash_int64(key) result(hash) Generate hash of key Arguments Type Intent Optional Attributes Name class( fhash_key_int64_t ), intent(in) :: key Return Value integer(kind=int64) procedure, public, pass :: equals => key_equal_int64 private pure function key_equal_int64(key1, key2) result(keys_equal) Check if two keys are equal Arguments Type Intent Optional Attributes Name class( fhash_key_int64_t ), intent(in) :: key1 class( fhash_key_t ), intent(in) :: key2 Return Value logical procedure, public, pass :: to_string => key_int64_to_string private pure function key_int64_to_string(key) result(str) Generate string representation of hash Arguments Type Intent Optional Attributes Name class( fhash_key_int64_t ), intent(in) :: key Return Value character(len=:), allocatable","tags":"","loc":"type/fhash_key_int64_t.html"},{"title":"fhash_key_int32_t – fhash API Reference ","text":"type, public, extends( fhash_key_t ) :: fhash_key_int32_t Hash table key container Contents Type-Bound Procedures operator(==) hash equals to_string Type-Bound Procedures generic, public :: operator(==) => equals private pure function key_equal_int64_1d(key1, key2) result(keys_equal) Check if two keys are equal Arguments Type Intent Optional Attributes Name class( fhash_key_int64_1d_t ), intent(in) :: key1 class( fhash_key_t ), intent(in) :: key2 Return Value logical procedure, public, pass :: hash => key_hash_int32 private pure function key_hash_int32(key) result(hash) Generate hash of key Arguments Type Intent Optional Attributes Name class( fhash_key_int32_t ), intent(in) :: key Return Value integer(kind=int64) procedure, public, pass :: equals => key_equal_int32 private pure function key_equal_int32(key1, key2) result(keys_equal) Check if two keys are equal Arguments Type Intent Optional Attributes Name class( fhash_key_int32_t ), intent(in) :: key1 class( fhash_key_t ), intent(in) :: key2 Return Value logical procedure, public, pass :: to_string => key_int32_to_string private pure function key_int32_to_string(key) result(str) Generate string representation of hash Arguments Type Intent Optional Attributes Name class( fhash_key_int32_t ), intent(in) :: key Return Value character(len=:), allocatable","tags":"","loc":"type/fhash_key_int32_t.html"},{"title":"fhash_key_int32_1d_t – fhash API Reference ","text":"type, public, extends( fhash_key_t ) :: fhash_key_int32_1d_t Hash table key container Contents Type-Bound Procedures operator(==) hash equals to_string Type-Bound Procedures generic, public :: operator(==) => equals private pure function key_equal_int64_1d(key1, key2) result(keys_equal) Check if two keys are equal Arguments Type Intent Optional Attributes Name class( fhash_key_int64_1d_t ), intent(in) :: key1 class( fhash_key_t ), intent(in) :: key2 Return Value logical procedure, public, pass :: hash => key_hash_int32_1d private pure function key_hash_int32_1d(key) result(hash) Generate hash of key Arguments Type Intent Optional Attributes Name class( fhash_key_int32_1d_t ), intent(in) :: key Return Value integer(kind=int64) procedure, public, pass :: equals => key_equal_int32_1d private pure function key_equal_int32_1d(key1, key2) result(keys_equal) Check if two keys are equal Arguments Type Intent Optional Attributes Name class( fhash_key_int32_1d_t ), intent(in) :: key1 class( fhash_key_t ), intent(in) :: key2 Return Value logical procedure, public, pass :: to_string => key_int32_1d_to_string private pure function key_int32_1d_to_string(key) result(str) Generate string representation of hash Arguments Type Intent Optional Attributes Name class( fhash_key_int32_1d_t ), intent(in) :: key Return Value character(len=:), allocatable","tags":"","loc":"type/fhash_key_int32_1d_t.html"},{"title":"node_depth – fhash API Reference","text":"public  function node_depth(node) result(depth) Determine depth of SLL Arguments Type Intent Optional Attributes Name type( fhash_node_t ), intent(in), target :: node Node to check depth Return Value integer Contents","tags":"","loc":"proc/node_depth.html"},{"title":"sll_push_node – fhash API Reference","text":"public recursive subroutine sll_push_node(node, key, value, pointer) Append node to SLL Arguments Type Intent Optional Attributes Name type( fhash_node_t ), intent(inout) :: node Node to which to add data class( fhash_key_t ), intent(in) :: key Key to add class(*), intent(in), target :: value Value to add logical, intent(in), optional :: pointer Store only a point if .true. Contents","tags":"","loc":"proc/sll_push_node.html"},{"title":"sll_node_set – fhash API Reference","text":"public  subroutine sll_node_set(node, value, pointer) Set container value in node Arguments Type Intent Optional Attributes Name type( fhash_node_t ), intent(inout) :: node Node to which to add data class(*), intent(in), target :: value Value to set logical, intent(in), optional :: pointer Store only a pointer if .true. Contents","tags":"","loc":"proc/sll_node_set.html"},{"title":"sll_find_in – fhash API Reference","text":"public recursive subroutine sll_find_in(node, key, data, found) Search for a node with a specific key.\nReturns a pointer to the 'data' component of the corresponding node.\nPointer is not associated if node cannot be found Arguments Type Intent Optional Attributes Name type( fhash_node_t ), intent(in), target :: node Node to search in class( fhash_key_t ) :: key Key to look for type( fhash_container_t ), intent(out), pointer :: data Pointer to value container if found.\n(Unassociated if the key is not found in node) logical, intent(out), optional :: found Contents","tags":"","loc":"proc/sll_find_in.html"},{"title":"sll_get_at – fhash API Reference","text":"public recursive subroutine sll_get_at(node, depth, key, data, found) Return a node at a specific depth in the sll Arguments Type Intent Optional Attributes Name type( fhash_node_t ), intent(in), target :: node Node to search in integer, intent(in) :: depth Node depth to access class( fhash_key_t ), intent(out), allocatable :: key Key of found item\n (Unallocated if no node is found at specified depth) type( fhash_container_t ), intent(out), pointer :: data Pointer to value container if found.\n(Unassociated if no node is found at specified depth) logical, intent(out), optional :: found Contents","tags":"","loc":"proc/sll_get_at.html"},{"title":"sll_remove – fhash API Reference","text":"public recursive subroutine sll_remove(node, key, found, parent_node) Search for a node with a specific key and remove Arguments Type Intent Optional Attributes Name type( fhash_node_t ), intent(inout) :: node Node to remove from class( fhash_key_t ) :: key Key to remove logical, intent(out), optional :: found Indicates if the key was found in node and removed type( fhash_node_t ), intent(inout), optional :: parent_node Used internally Contents","tags":"","loc":"proc/sll_remove.html"},{"title":"sll_clean – fhash API Reference","text":"public recursive subroutine sll_clean(node) Deallocate node components and those of its children Arguments Type Intent Optional Attributes Name type( fhash_node_t ), intent(inout) :: node Node to search in Contents","tags":"","loc":"proc/sll_clean.html"},{"title":"fhash_container – fhash API Reference","text":"public interface fhash_container Create a fhash_container object from a polymorphic value Contents Module Procedures fhash_container_scalar Module Procedures private  function fhash_container_scalar(value, pointer) result(container) Helper to initialise a polymorphic data container with scalar Arguments Type Intent Optional Attributes Name class(*), intent(in), target :: value Value to store logical, intent(in), optional :: pointer If .true., store pointer to value instead of copying Return Value type( fhash_container_t )","tags":"","loc":"interface/fhash_container.html"},{"title":"hash_string – fhash API Reference","text":"public  function hash_string(hash_value) result(str) Help fcn to convert hash to hex representation Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: hash_value Return Value character(len=:), allocatable Contents","tags":"","loc":"proc/hash_string.html"},{"title":"fnv_1a – fhash API Reference","text":"public interface fnv_1a Generic interface to perform hashing Usage: fnv_1a ([ seed ], input ) where input is any of the supported types Contents Module Procedures fnv_1a_char_scalar fnv_1a_char_scalar_seed fnv_1a_int32_scalar fnv_1a_int32_scalar_seed fnv_1a_int32_1d fnv_1a_int32_1d_seed fnv_1a_int64_scalar fnv_1a_int64_scalar_seed fnv_1a_int64_1d fnv_1a_int64_1d_seed Module Procedures private pure function fnv_1a_char_scalar(input) result(hash) Hash a single default kind character variable Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input Return Value integer(kind=int64) private pure function fnv_1a_char_scalar_seed(seed, input) result(hash) Hash a character(*) string of default kind Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: seed character(len=*), intent(in) :: input Return Value integer(kind=int64) private pure function fnv_1a_int32_scalar(input) result(hash) Hash a single 32bit integer Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: input Return Value integer(kind=int64) private pure function fnv_1a_int32_scalar_seed(seed, input) result(hash) Hash a single 32bit integer with a starting seed Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: seed integer(kind=int32), intent(in) :: input Return Value integer(kind=int64) private pure function fnv_1a_int32_1d(input) result(hash) Hash a 1D array of 32bit integers Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: input (:) Return Value integer(kind=int64) private pure function fnv_1a_int32_1d_seed(seed, input) result(hash) Hash a 1D array of 32bit integers with a starting seed Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: seed integer(kind=int32), intent(in) :: input (:) Return Value integer(kind=int64) private pure function fnv_1a_int64_scalar(input) result(hash) Hash a single 64bit integer Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: input Return Value integer(kind=int64) private pure function fnv_1a_int64_scalar_seed(seed, input) result(hash) Hash a single 64bit integer with a starting seed Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: seed integer(kind=int64), intent(in) :: input Return Value integer(kind=int64) private pure function fnv_1a_int64_1d(input) result(hash) Hash a 1D array of 64bit integers Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: input (:) Return Value integer(kind=int64) private pure function fnv_1a_int64_1d_seed(seed, input) result(hash) Hash a 1D array of 64bit integers with a starting seed Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: seed integer(kind=int64), intent(in) :: input (:) Return Value integer(kind=int64)","tags":"","loc":"interface/fnv_1a.html"},{"title":"fhash_iter_t – fhash API Reference","text":"public interface fhash_iter_t Contents Module Procedures fhash_iter_init Module Procedures private  function fhash_iter_init(tbl) result(iter) Initialise fhash iterator Arguments Type Intent Optional Attributes Name type( fhash_tbl_t ), intent(in), target :: tbl Return Value type( fhash_iter_t )","tags":"","loc":"interface/fhash_iter_t.html"},{"title":"fhash_key – fhash API Reference","text":"public interface fhash_key Contents Module Procedures key_from_char Module Procedures private  function key_from_char(source) result(key) Create new key container from a scalar int32 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: source Return Value type( fhash_key_char_t )","tags":"","loc":"interface/fhash_key.html"},{"title":"fhash_key – fhash API Reference","text":"public interface fhash_key Contents Module Procedures key_from_int64_1d Module Procedures private  function key_from_int64_1d(source) result(key) Create new key container from a scalar int64 Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: source (:) Return Value type( fhash_key_int64_1d_t )","tags":"","loc":"interface/fhash_key~2.html"},{"title":"fhash_key – fhash API Reference","text":"public interface fhash_key Contents Module Procedures key_from_int64 Module Procedures private  function key_from_int64(source) result(key) Create new key container from a scalar int64 Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: source Return Value type( fhash_key_int64_t )","tags":"","loc":"interface/fhash_key~3.html"},{"title":"fhash_key – fhash API Reference","text":"public interface fhash_key Contents Module Procedures key_from_int32 Module Procedures private  function key_from_int32(source) result(key) Create new key container from a scalar int32 Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: source Return Value type( fhash_key_int32_t )","tags":"","loc":"interface/fhash_key~4.html"},{"title":"fhash_key – fhash API Reference","text":"public interface fhash_key Contents Module Procedures key_from_int32_1d Module Procedures private  function key_from_int32_1d(source) result(key) Create new key container from a scalar int32 Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: source (:) Return Value type( fhash_key_int32_1d_t )","tags":"","loc":"interface/fhash_key~5.html"},{"title":"fhash_sll – fhash API Reference","text":"Implements singly-linked list (sll) node with generic data container Uses fhash_data_container iso_fortran_env fhash_key_base Contents Derived Types fhash_node_t Functions node_depth Subroutines sll_push_node sll_node_set sll_find_in sll_get_at sll_remove sll_clean Derived Types type, public :: fhash_node_t Node type for hash table singly linked list Components Type Visibility Attributes Name Initial class( fhash_key_t ), public, allocatable :: key type( fhash_container_t ), public :: value type( fhash_node_t ), public, pointer :: next => NULL() Functions public  function node_depth (node) result(depth) Determine depth of SLL Arguments Type Intent Optional Attributes Name type( fhash_node_t ), intent(in), target :: node Node to check depth Return Value integer Subroutines public recursive subroutine sll_push_node (node, key, value, pointer) Append node to SLL Arguments Type Intent Optional Attributes Name type( fhash_node_t ), intent(inout) :: node Node to which to add data class( fhash_key_t ), intent(in) :: key Key to add class(*), intent(in), target :: value Value to add logical, intent(in), optional :: pointer Store only a point if .true. public  subroutine sll_node_set (node, value, pointer) Set container value in node Arguments Type Intent Optional Attributes Name type( fhash_node_t ), intent(inout) :: node Node to which to add data class(*), intent(in), target :: value Value to set logical, intent(in), optional :: pointer Store only a pointer if .true. public recursive subroutine sll_find_in (node, key, data, found) Search for a node with a specific key.\nReturns a pointer to the 'data' component of the corresponding node.\nPointer is not associated if node cannot be found Arguments Type Intent Optional Attributes Name type( fhash_node_t ), intent(in), target :: node Node to search in class( fhash_key_t ) :: key Key to look for type( fhash_container_t ), intent(out), pointer :: data Pointer to value container if found.\n(Unassociated if the key is not found in node) logical, intent(out), optional :: found public recursive subroutine sll_get_at (node, depth, key, data, found) Return a node at a specific depth in the sll Arguments Type Intent Optional Attributes Name type( fhash_node_t ), intent(in), target :: node Node to search in integer, intent(in) :: depth Node depth to access class( fhash_key_t ), intent(out), allocatable :: key Key of found item\n (Unallocated if no node is found at specified depth) type( fhash_container_t ), intent(out), pointer :: data Pointer to value container if found.\n(Unassociated if no node is found at specified depth) logical, intent(out), optional :: found public recursive subroutine sll_remove (node, key, found, parent_node) Search for a node with a specific key and remove Arguments Type Intent Optional Attributes Name type( fhash_node_t ), intent(inout) :: node Node to remove from class( fhash_key_t ) :: key Key to remove logical, intent(out), optional :: found Indicates if the key was found in node and removed type( fhash_node_t ), intent(inout), optional :: parent_node Used internally public recursive subroutine sll_clean (node) Deallocate node components and those of its children Arguments Type Intent Optional Attributes Name type( fhash_node_t ), intent(inout) :: node Node to search in","tags":"","loc":"module/fhash_sll.html"},{"title":"fhash_data_container – fhash API Reference","text":"Implements simple container type\n for polymorphic scalars and 1D arrays Uses iso_fortran_env Contents Interfaces fhash_container Derived Types fhash_container_t Interfaces public        interface fhash_container Create a fhash_container object from a polymorphic value private  function fhash_container_scalar(value, pointer) result(container) Helper to initialise a polymorphic data container with scalar Arguments Type Intent Optional Attributes Name class(*), intent(in), target :: value Value to store logical, intent(in), optional :: pointer If .true., store pointer to value instead of copying Return Value type( fhash_container_t ) Derived Types type, public :: fhash_container_t Generic container for scalar and 1D data Components Type Visibility Attributes Name Initial class(*), public, allocatable :: scalar_data class(*), public, pointer :: scalar_ptr => NULL() Type-Bound Procedures procedure\n                    ,                  public\n,                   :: allocated =>\n                    fhash_container_allocated Function procedure\n                    ,                  public\n,                   :: get =>\n                    fhash_container_get_scalar Subroutine procedure\n                    ,                  public\n,                   :: get_ptr =>\n                    fhash_container_get_scalar_ptr Subroutine","tags":"","loc":"module/fhash_data_container.html"},{"title":"fhash_fnv – fhash API Reference","text":"A module for Fowler–Noll–Vo (FNV) hashing Implements the FNV 1a algorithm for 32bit hashes Supports hashing of:\n - 32bit integers (scalar & 1D array)\n - 64bit integers (scalar & 1D array)\n - character(*), default kind The lack of unsigned arithmetic in Fortran means that\n  64bit arithmetic is needed to perform 32bit hashing.\n Hashes are therefore returned as int64. Uses iso_fortran_env iso_c_binding Contents Interfaces fnv_1a Functions hash_string Interfaces public        interface fnv_1a Generic interface to perform hashing Usage: fnv_1a ([ seed ], input ) where input is any of the supported types private pure function fnv_1a_char_scalar(input) result(hash) Hash a single default kind character variable Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input Return Value integer(kind=int64) private pure function fnv_1a_char_scalar_seed(seed, input) result(hash) Hash a character(*) string of default kind Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: seed character(len=*), intent(in) :: input Return Value integer(kind=int64) private pure function fnv_1a_int32_scalar(input) result(hash) Hash a single 32bit integer Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: input Return Value integer(kind=int64) private pure function fnv_1a_int32_scalar_seed(seed, input) result(hash) Hash a single 32bit integer with a starting seed Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: seed integer(kind=int32), intent(in) :: input Return Value integer(kind=int64) private pure function fnv_1a_int32_1d(input) result(hash) Hash a 1D array of 32bit integers Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: input (:) Return Value integer(kind=int64) private pure function fnv_1a_int32_1d_seed(seed, input) result(hash) Hash a 1D array of 32bit integers with a starting seed Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: seed integer(kind=int32), intent(in) :: input (:) Return Value integer(kind=int64) private pure function fnv_1a_int64_scalar(input) result(hash) Hash a single 64bit integer Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: input Return Value integer(kind=int64) private pure function fnv_1a_int64_scalar_seed(seed, input) result(hash) Hash a single 64bit integer with a starting seed Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: seed integer(kind=int64), intent(in) :: input Return Value integer(kind=int64) private pure function fnv_1a_int64_1d(input) result(hash) Hash a 1D array of 64bit integers Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: input (:) Return Value integer(kind=int64) private pure function fnv_1a_int64_1d_seed(seed, input) result(hash) Hash a 1D array of 64bit integers with a starting seed Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: seed integer(kind=int64), intent(in) :: input (:) Return Value integer(kind=int64) Functions public  function hash_string (hash_value) result(str) Help fcn to convert hash to hex representation Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: hash_value Return Value character(len=:), allocatable","tags":"","loc":"module/fhash_fnv.html"},{"title":"fhash_tbl_iter – fhash API Reference","text":"Uses fhash_data_container fhash_tbl fhash_sll fhash_key_base Contents Interfaces fhash_iter_t Derived Types fhash_iter_t Interfaces public        interface fhash_iter_t private  function fhash_iter_init(tbl) result(iter) Initialise fhash iterator Arguments Type Intent Optional Attributes Name type( fhash_tbl_t ), intent(in), target :: tbl Return Value type( fhash_iter_t ) Derived Types type, public :: fhash_iter_t Iterator type for iterating over hash table items Components Type Visibility Attributes Name Initial type( fhash_tbl_t ), public, pointer :: tbl => NULL() integer, public :: bucket = 1 integer, public :: depth = 1 Constructor private\n\n                    \n                    function fhash_iter_init (tbl) Initialise fhash iterator Type-Bound Procedures procedure\n                    ,                  public\n,                   :: next =>\n                    fhash_iter_next Function procedure\n                    ,                  public\n,                   :: reset =>\n                    fhash_iter_reset Subroutine","tags":"","loc":"module/fhash_tbl_iter.html"},{"title":"fhash_tbl – fhash API Reference","text":"Uses fhash_data_container iso_fortran_env fhash_sll Contents Variables FHASH_INTERNAL_ERROR FHASH_EMPTY_TABLE FHASH_FOUND_WRONG_TYPE FHASH_KEY_NOT_FOUND Derived Types fhash_tbl_t Variables Type Visibility Attributes Name Initial integer, public, parameter :: FHASH_INTERNAL_ERROR = -4 This condition should be unreachable by the public interface integer, public, parameter :: FHASH_EMPTY_TABLE = -3 Error flag for operating on an unallocated table integer, public, parameter :: FHASH_FOUND_WRONG_TYPE = -2 Error flag for when retrieved data-type does not \n match that expected by the invoked getter function \n ( get_int32 , get_int63 , get_float ,'get_double , get_char`) integer, public, parameter :: FHASH_KEY_NOT_FOUND = -1 Error flag for when specified key is not found in the hash table Derived Types type, public :: fhash_tbl_t Components Type Visibility Attributes Name Initial type( fhash_node_t ), public, allocatable :: buckets (:) Finalizations Procedures final :: fhash_tbl_cleanup Type-Bound Procedures procedure\n                    ,                  public\n,                   :: allocate =>\n                    fhash_tbl_allocate Subroutine procedure\n                    ,                  public\n,                   :: unset =>\n                    fhash_tbl_unset Subroutine procedure\n                    ,                  public\n,                   :: check_key =>\n                    fhash_tbl_check_key Subroutine procedure\n                    ,                  public\n,                   :: stats =>\n                    fhash_tbl_stats Subroutine procedure\n                    ,                  public\n,                   :: fhash_tbl_set_scalar Subroutine generic,\n                  public\n,                   :: set => fhash_tbl_set_scalar procedure\n                    ,                  public\n,                   :: fhash_tbl_set_scalar_ptr Subroutine generic,\n                  public\n,                   :: set_ptr => fhash_tbl_set_scalar_ptr procedure\n                    ,                  public\n,                   :: fhash_tbl_get_int64 Subroutine procedure\n                    ,                  public\n,                   :: fhash_tbl_get_int32 Subroutine procedure\n                    ,                  public\n,                   :: fhash_tbl_get_double Subroutine procedure\n                    ,                  public\n,                   :: fhash_tbl_get_float Subroutine procedure\n                    ,                  public\n,                   :: fhash_tbl_get_logical Subroutine procedure\n                    ,                  public\n,                   :: fhash_tbl_get_char Subroutine procedure\n                    ,                  public\n,                   :: fhash_tbl_get_raw Subroutine procedure\n                    ,                  public\n,                   :: fhash_tbl_get_data Subroutine generic,\n                  public\n,                   :: get => fhash_tbl_get_int32 , fhash_tbl_get_int64 generic,\n                  public\n,                   :: get => fhash_tbl_get_float , fhash_tbl_get_double generic,\n                  public\n,                   :: get => fhash_tbl_get_char , fhash_tbl_get_logical generic,\n                  public\n,                   :: get => fhash_tbl_get_data generic,\n                  public\n,                   :: get_raw => fhash_tbl_get_raw procedure\n                    ,                  public\n,                   :: fhash_tbl_get_int64_ptr Subroutine procedure\n                    ,                  public\n,                   :: fhash_tbl_get_int32_ptr Subroutine procedure\n                    ,                  public\n,                   :: fhash_tbl_get_double_ptr Subroutine procedure\n                    ,                  public\n,                   :: fhash_tbl_get_float_ptr Subroutine procedure\n                    ,                  public\n,                   :: fhash_tbl_get_logical_ptr Subroutine procedure\n                    ,                  public\n,                   :: fhash_tbl_get_char_ptr Subroutine procedure\n                    ,                  public\n,                   :: fhash_tbl_get_raw_ptr Subroutine generic,\n                  public\n,                   :: get_ptr => fhash_tbl_get_int32_ptr , fhash_tbl_get_int64_ptr generic,\n                  public\n,                   :: get_ptr => fhash_tbl_get_float_ptr , fhash_tbl_get_double_ptr generic,\n                  public\n,                   :: get_ptr => fhash_tbl_get_char_ptr , fhash_tbl_get_logical_ptr generic,\n                  public\n,                   :: get_raw_ptr => fhash_tbl_get_raw_ptr","tags":"","loc":"module/fhash_tbl.html"},{"title":"fhash – fhash API Reference","text":"Uses fhash_key_int32_1d fhash_tbl fhash_key_char fhash_key_int64 fhash_key_base fhash_tbl_iter fhash_key_int32 fhash_key_int64_1d Contents None","tags":"","loc":"module/fhash.html"},{"title":"fhash_key_char – fhash API Reference","text":"Implements a concrete type for scalar int32 hash keys Uses iso_fortran_env fhash_fnv fhash_key_base Contents Interfaces fhash_key Derived Types fhash_key_char_t Interfaces public        interface fhash_key private  function key_from_char(source) result(key) Create new key container from a scalar int32 Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: source Return Value type( fhash_key_char_t ) Derived Types type, public, extends( fhash_key_t ) :: fhash_key_char_t Hash table key container Type-Bound Procedures generic,\n                  public\n                  :: operator(==) => equals procedure\n                    ,                  public\n, pass                  :: hash =>\n                    key_hash_char Function procedure\n                    ,                  public\n, pass                  :: equals =>\n                    key_equal_char Function procedure\n                    ,                  public\n, pass                  :: to_string =>\n                    key_char_to_string Function","tags":"","loc":"module/fhash_key_char.html"},{"title":"fhash_key_base – fhash API Reference","text":"Implements an abstract type for hash keys Uses iso_fortran_env Contents Derived Types fhash_key_t Derived Types type, public :: fhash_key_t Abstract base type for defining hash keys Type-Bound Procedures procedure\n(hash_proc)                    ,                  public\n                  :: hash procedure\n(equality_proc)                    ,                  public\n                  :: equals procedure\n(to_string_proc)                    ,                  public\n                  :: to_string generic,\n                  public\n                  :: operator(==) => equals","tags":"","loc":"module/fhash_key_base.html"},{"title":"fhash_key_int64_1d – fhash API Reference","text":"Implements a concrete type for 1D int64 array hash keys Uses iso_fortran_env fhash_fnv fhash_key_base Contents Interfaces fhash_key Derived Types fhash_key_int64_1d_t Interfaces public        interface fhash_key private  function key_from_int64_1d(source) result(key) Create new key container from a scalar int64 Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: source (:) Return Value type( fhash_key_int64_1d_t ) Derived Types type, public, extends( fhash_key_t ) :: fhash_key_int64_1d_t Hash table key container Type-Bound Procedures generic,\n                  public\n                  :: operator(==) => equals procedure\n                    ,                  public\n, pass                  :: hash =>\n                    key_hash_int64_1d Function procedure\n                    ,                  public\n, pass                  :: equals =>\n                    key_equal_int64_1d Function procedure\n                    ,                  public\n, pass                  :: to_string =>\n                    key_int64_1d_to_string Function","tags":"","loc":"module/fhash_key_int64_1d.html"},{"title":"fhash_key_int64 – fhash API Reference","text":"Implements a concrete type for scalar int64 hash keys Uses iso_fortran_env fhash_fnv fhash_key_base Contents Interfaces fhash_key Derived Types fhash_key_int64_t Interfaces public        interface fhash_key private  function key_from_int64(source) result(key) Create new key container from a scalar int64 Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: source Return Value type( fhash_key_int64_t ) Derived Types type, public, extends( fhash_key_t ) :: fhash_key_int64_t Hash table key container Type-Bound Procedures generic,\n                  public\n                  :: operator(==) => equals procedure\n                    ,                  public\n, pass                  :: hash =>\n                    key_hash_int64 Function procedure\n                    ,                  public\n, pass                  :: equals =>\n                    key_equal_int64 Function procedure\n                    ,                  public\n, pass                  :: to_string =>\n                    key_int64_to_string Function","tags":"","loc":"module/fhash_key_int64.html"},{"title":"fhash_key_int32 – fhash API Reference","text":"Implements a concrete type for scalar int32 hash keys Uses iso_fortran_env fhash_fnv fhash_key_base Contents Interfaces fhash_key Derived Types fhash_key_int32_t Interfaces public        interface fhash_key private  function key_from_int32(source) result(key) Create new key container from a scalar int32 Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: source Return Value type( fhash_key_int32_t ) Derived Types type, public, extends( fhash_key_t ) :: fhash_key_int32_t Hash table key container Type-Bound Procedures generic,\n                  public\n                  :: operator(==) => equals procedure\n                    ,                  public\n, pass                  :: hash =>\n                    key_hash_int32 Function procedure\n                    ,                  public\n, pass                  :: equals =>\n                    key_equal_int32 Function procedure\n                    ,                  public\n, pass                  :: to_string =>\n                    key_int32_to_string Function","tags":"","loc":"module/fhash_key_int32.html"},{"title":"fhash_key_int32_1d – fhash API Reference","text":"Implements a concrete type for 1D int32 array hash keys Uses iso_fortran_env fhash_fnv fhash_key_base Contents Interfaces fhash_key Derived Types fhash_key_int32_1d_t Interfaces public        interface fhash_key private  function key_from_int32_1d(source) result(key) Create new key container from a scalar int32 Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: source (:) Return Value type( fhash_key_int32_1d_t ) Derived Types type, public, extends( fhash_key_t ) :: fhash_key_int32_1d_t Hash table key container Type-Bound Procedures generic,\n                  public\n                  :: operator(==) => equals procedure\n                    ,                  public\n, pass                  :: hash =>\n                    key_hash_int32_1d Function procedure\n                    ,                  public\n, pass                  :: equals =>\n                    key_equal_int32_1d Function procedure\n                    ,                  public\n, pass                  :: to_string =>\n                    key_int32_1d_to_string Function","tags":"","loc":"module/fhash_key_int32_1d.html"},{"title":"fhash_sll.f90 – fhash API Reference","text":"Contents Modules fhash_sll Source Code fhash_sll.f90 Source Code !> Implements singly-linked list (sll) node with generic data container !> module fhash_sll use iso_fortran_env , only : int32 , int64 use fhash_key_base , only : fhash_key_t use fhash_data_container , only : fhash_container_t implicit none !> Node type for hash table singly linked list type fhash_node_t class ( fhash_key_t ), allocatable :: key type ( fhash_container_t ) :: value type ( fhash_node_t ), pointer :: next => NULL () end type fhash_node_t contains !> Append node to SLL recursive subroutine sll_push_node ( node , key , value , pointer ) !> Node to which to add data type ( fhash_node_t ), intent ( inout ) :: node !> Key to add class ( fhash_key_t ), intent ( in ) :: key !> Value to add class ( * ), intent ( in ), target :: value !> Store only a point if .true. logical , intent ( in ), optional :: pointer if ( allocated ( node % key )) then if ( node % key == key ) then call sll_node_set ( node , value , pointer ) return end if if (. not . associated ( node % next )) then allocate ( node % next ) end if call sll_push_node ( node % next , key , value , pointer ) else node % key = key call sll_node_set ( node , value , pointer ) end if end subroutine sll_push_node !> Set container value in node !> subroutine sll_node_set ( node , value , pointer ) !> Node to which to add data type ( fhash_node_t ), intent ( inout ) :: node !> Value to set class ( * ), intent ( in ), target :: value !> Store only a pointer if .true. logical , intent ( in ), optional :: pointer if ( present ( pointer )) then if ( pointer ) then node % value % scalar_ptr => value return end if end if if ( allocated ( node % value % scalar_data )) deallocate ( node % value % scalar_data ) allocate ( node % value % scalar_data , source = value ) end subroutine sll_node_set !> Search for a node with a specific key. !> Returns a pointer to the 'data' component of the corresponding node. !> Pointer is not associated if node cannot be found recursive subroutine sll_find_in ( node , key , data , found ) !> Node to search in type ( fhash_node_t ), intent ( in ), target :: node !> Key to look for class ( fhash_key_t ) :: key !> Pointer to value container if found. !> (Unassociated if the key is not found in node) type ( fhash_container_t ), pointer , intent ( out ) :: data logical , intent ( out ), optional :: found data => NULL () if ( present ( found )) found = . false . if (. not . allocated ( node % key )) then return else if ( node % key == key ) then if ( present ( found )) found = . true . data => node % value return else if ( associated ( node % next )) then call sll_find_in ( node % next , key , data , found ) end if end subroutine sll_find_in !> Return a node at a specific depth in the sll recursive subroutine sll_get_at ( node , depth , key , data , found ) !> Node to search in type ( fhash_node_t ), intent ( in ), target :: node !> Node depth to access integer , intent ( in ) :: depth !> Key of found item !>  (Unallocated if no node is found at specified depth) class ( fhash_key_t ), intent ( out ), allocatable :: key !> Pointer to value container if found. !> (Unassociated if no node is found at specified depth) type ( fhash_container_t ), pointer , intent ( out ) :: data logical , intent ( out ), optional :: found data => NULL () if ( present ( found )) found = . false . if (. not . allocated ( node % key )) then return else if ( depth == 1 ) then if ( present ( found )) found = . true . key = node % key data => node % value return else if ( associated ( node % next )) then call sll_get_at ( node % next , depth - 1 , key , data , found ) end if end subroutine sll_get_at !> Search for a node with a specific key and remove recursive subroutine sll_remove ( node , key , found , parent_node ) !> Node to remove from type ( fhash_node_t ), intent ( inout ) :: node !> Key to remove class ( fhash_key_t ) :: key !> Indicates if the key was found in node and removed logical , optional , intent ( out ) :: found !> Used internally type ( fhash_node_t ), intent ( inout ), optional :: parent_node type ( fhash_node_t ), pointer :: next_temp if ( present ( found )) then found = . false . end if if (. not . allocated ( node % key )) then return else if ( node % key == key ) then if ( present ( found )) then found = . true . end if if (. not . present ( parent_node )) then ! This is the top-level node if ( associated ( node % next )) then ! Replace with next next_temp => node % next node = next_temp deallocate ( next_temp ) return else ! No children, just deallocate deallocate ( node % key ) return end if else ! Not top-level node if ( associated ( node % next )) then ! Join previous with next next_temp => node % next deallocate ( parent_node % next ) parent_node % next => next_temp return else ! No children, just deallocate deallocate ( node % key ) deallocate ( parent_node % next ) return end if end if else if ( associated ( node % next )) then ! Look further down call sll_remove ( node % next , key , found , node ) end if end subroutine sll_remove !> Deallocate node components and those of its children recursive subroutine sll_clean ( node ) !> Node to search in type ( fhash_node_t ), intent ( inout ) :: node if ( associated ( node % next )) then call sll_clean ( node % next ) deallocate ( node % next ) end if end subroutine sll_clean !> Determine depth of SLL function node_depth ( node ) result ( depth ) !> Node to check depth type ( fhash_node_t ), intent ( in ), target :: node integer :: depth type ( fhash_node_t ), pointer :: current if (. not . allocated ( node % key )) then depth = 0 return else depth = 1 current => node do while ( associated ( current % next )) depth = depth + 1 current => current % next end do end if end function node_depth end module fhash_sll","tags":"","loc":"sourcefile/fhash_sll.f90.html"},{"title":"fhash_data_container.f90 – fhash API Reference","text":"Contents Modules fhash_data_container Source Code fhash_data_container.f90 Source Code !> Implements simple container type !>  for polymorphic scalars and 1D arrays module fhash_data_container use iso_fortran_env , only : sp => real32 , dp => real64 , int32 , int64 implicit none private public fhash_container_t public fhash_container !> Generic container for scalar and 1D data type fhash_container_t class ( * ), allocatable :: scalar_data class ( * ), pointer :: scalar_ptr => NULL () contains procedure :: allocated => fhash_container_allocated procedure :: get => fhash_container_get_scalar procedure :: get_ptr => fhash_container_get_scalar_ptr end type fhash_container_t !> Create a fhash_container object from a polymorphic value interface fhash_container module procedure fhash_container_scalar end interface fhash_container contains !> Helper to initialise a polymorphic data container with scalar function fhash_container_scalar ( value , pointer ) result ( container ) !> Value to store class ( * ), intent ( in ), target :: value !> If .true., store pointer to value instead of copying logical , intent ( in ), optional :: pointer type ( fhash_container_t ) :: container if ( present ( pointer )) then if ( pointer ) then container % scalar_ptr => value else if ( allocated ( container % scalar_data )) deallocate ( container % scalar_data ) allocate ( container % scalar_data , source = value ) end if else if ( allocated ( container % scalar_data )) deallocate ( container % scalar_data ) allocate ( container % scalar_data , source = value ) end if end function fhash_container_scalar !> Helper to determine if container contains anything function fhash_container_allocated ( container ) result ( alloc ) class ( fhash_container_t ), intent ( in ) :: container logical :: alloc alloc = allocated ( container % scalar_data ) . OR . & associated ( container % scalar_ptr ) end function fhash_container_allocated !> Helper to return container value as intrinsic type subroutine fhash_container_get_scalar ( container , i32 , i64 , r32 , r64 , char , bool , raw , match , type_string ) class ( fhash_container_t ), intent ( in ), target :: container integer ( int32 ), intent ( out ), optional :: i32 integer ( int64 ), intent ( out ), optional :: i64 real ( sp ), intent ( out ), optional :: r32 real ( dp ), intent ( out ), optional :: r64 character (:), allocatable , intent ( out ), optional :: char logical , intent ( out ), optional :: bool class ( * ), allocatable , intent ( out ), optional :: raw logical , intent ( out ), optional :: match character (:), allocatable , intent ( out ), optional :: type_string class ( * ), pointer :: data if ( present ( match )) match = . false . if (. not . container % allocated ()) return if ( allocated ( container % scalar_data )) then data => container % scalar_data else data => container % scalar_ptr end if if ( present ( raw )) then if ( present ( match )) match = . true . allocate ( raw , source = data ) end if select type ( d => data ) type is ( integer ( int32 )) if ( present ( type_string )) type_string = 'integer32' if ( present ( i32 )) then if ( present ( match )) match = . true . i32 = d return end if type is ( integer ( int64 )) if ( present ( type_string )) type_string = 'integer64' if ( present ( i64 )) then if ( present ( match )) match = . true . i64 = d return end if type is ( real ( sp )) if ( present ( type_string )) type_string = 'real32' if ( present ( r32 )) then if ( present ( match )) match = . true . r32 = d return end if type is ( real ( dp )) if ( present ( type_string )) type_string = 'real64' if ( present ( r64 )) then if ( present ( match )) match = . true . r64 = d return end if type is ( character ( * )) if ( present ( type_string )) type_string = 'character*' if ( present ( char )) then if ( present ( match )) match = . true . char = d return end if type is ( logical ) if ( present ( type_string )) type_string = 'logical' if ( present ( bool )) then if ( present ( match )) match = . true . bool = d return end if class default if ( present ( type_string )) type_string = 'unknown' end select end subroutine fhash_container_get_scalar !> Helper to return pointer to container value as intrinsic type subroutine fhash_container_get_scalar_ptr ( container , i32 , i64 , r32 , r64 , char , bool , raw , match , type_string ) class ( fhash_container_t ), intent ( in ), target :: container integer ( int32 ), pointer , intent ( out ), optional :: i32 integer ( int64 ), pointer , intent ( out ), optional :: i64 real ( sp ), pointer , intent ( out ), optional :: r32 real ( dp ), pointer , intent ( out ), optional :: r64 character (:), pointer , intent ( out ), optional :: char logical , pointer , intent ( out ), optional :: bool class ( * ), pointer , intent ( out ), optional :: raw logical , intent ( out ), optional :: match character (:), allocatable , intent ( out ), optional :: type_string class ( * ), pointer :: data if ( present ( match )) match = . false . if (. not . container % allocated ()) return if ( allocated ( container % scalar_data )) then data => container % scalar_data else data => container % scalar_ptr end if if ( present ( raw )) then if ( present ( match )) match = . true . raw => data end if select type ( d => data ) type is ( integer ( int32 )) if ( present ( i32 )) then if ( present ( match )) match = . true . if ( present ( type_string )) type_string = 'integer32' i32 => d return end if type is ( integer ( int64 )) if ( present ( i64 )) then if ( present ( match )) match = . true . if ( present ( type_string )) type_string = 'integer64' i64 => d return end if type is ( real ( sp )) if ( present ( r32 )) then if ( present ( match )) match = . true . if ( present ( type_string )) type_string = 'real32' r32 => d return end if type is ( real ( dp )) if ( present ( r64 )) then if ( present ( match )) match = . true . if ( present ( type_string )) type_string = 'real64' r64 => d return end if type is ( character ( * )) if ( present ( char )) then if ( present ( match )) match = . true . if ( present ( type_string )) type_string = 'character*' char => d return end if type is ( logical ) if ( present ( bool )) then if ( present ( match )) match = . true . if ( present ( type_string )) type_string = 'logical' bool => d return end if class default if ( present ( type_string )) type_string = 'unknown' end select end subroutine fhash_container_get_scalar_ptr end module fhash_data_container","tags":"","loc":"sourcefile/fhash_data_container.f90.html"},{"title":"fhash_fnv.f90 – fhash API Reference","text":"Contents Modules fhash_fnv Source Code fhash_fnv.f90 Source Code !> A module for Fowler–Noll–Vo (FNV) hashing !> !> Implements the FNV 1a algorithm for 32bit hashes !> !> Supports hashing of: !>  - 32bit integers (scalar & 1D array) !>  - 64bit integers (scalar & 1D array) !>  - character(*), default kind !> !>  The lack of unsigned arithmetic in Fortran means that !>   64bit arithmetic is needed to perform 32bit hashing. !>  Hashes are therefore returned as int64. !> module fhash_fnv use iso_fortran_env , only : int32 , int64 use iso_c_binding , only : c_char implicit none private public :: fnv_1a , hash_string !> Starting seed integer ( int64 ), parameter :: FNV_OFFSET_32 = 2166136261_int64 !> Hashing prime integer ( int64 ), parameter :: FNV_PRIME_32 = 16777619_int64 !> Generic interface to perform hashing !> !> Usage: !>```fortran !> fnv_1a([seed],input) !>``` !> where `input` is any of the supported types interface fnv_1a module procedure fnv_1a_char_scalar module procedure fnv_1a_char_scalar_seed module procedure fnv_1a_int32_scalar module procedure fnv_1a_int32_scalar_seed module procedure fnv_1a_int32_1d module procedure fnv_1a_int32_1d_seed module procedure fnv_1a_int64_scalar module procedure fnv_1a_int64_scalar_seed module procedure fnv_1a_int64_1d module procedure fnv_1a_int64_1d_seed end interface fnv_1a contains !> Hash a single default kind character variable pure function fnv_1a_char_scalar ( input ) result ( hash ) character ( * ), intent ( in ) :: input integer ( int64 ) :: hash hash = fnv_1a ( FNV_OFFSET_32 , input ) end function fnv_1a_char_scalar !> Hash a character(*) string of default kind pure function fnv_1a_char_scalar_seed ( seed , input ) result ( hash ) integer ( int64 ), intent ( in ) :: seed character ( * ), intent ( in ) :: input integer ( int64 ) :: hash integer :: i integer ( int64 ) :: item hash = seed do i = 1 , len ( input ) item = transfer ([ iachar ( input ( i : i ), int32 ), 0_int32 ], item ) hash = ieor ( hash , item ) * fnv_prime_32 end do end function fnv_1a_char_scalar_seed !> Hash a single 32bit integer pure function fnv_1a_int32_scalar ( input ) result ( hash ) integer ( int32 ), intent ( in ) :: input integer ( int64 ) :: hash hash = fnv_1a ( FNV_OFFSET_32 , input ) end function fnv_1a_int32_scalar !> Hash a single 32bit integer with a starting seed pure function fnv_1a_int32_scalar_seed ( seed , input ) result ( hash ) integer ( int64 ), intent ( in ) :: seed integer ( int32 ), intent ( in ) :: input integer ( int64 ) :: hash character ( len = 4 , kind = c_char ) :: chars chars = transfer ( input , chars ) hash = fnv_1a ( seed , chars ) end function fnv_1a_int32_scalar_seed !> Hash a 1D array of 32bit integers pure function fnv_1a_int32_1d ( input ) result ( hash ) integer ( int32 ), intent ( in ) :: input (:) integer ( int64 ) :: hash hash = fnv_1a ( FNV_OFFSET_32 , input ) end function fnv_1a_int32_1d !> Hash a 1D array of 32bit integers with a starting seed pure function fnv_1a_int32_1d_seed ( seed , input ) result ( hash ) integer ( int64 ), intent ( in ) :: seed integer ( int32 ), intent ( in ) :: input (:) integer ( int64 ) :: hash integer :: i hash = seed do i = 1 , size ( input ) hash = fnv_1a ( hash , input ( i )) end do end function fnv_1a_int32_1d_seed !> Hash a single 64bit integer pure function fnv_1a_int64_scalar ( input ) result ( hash ) integer ( int64 ), intent ( in ) :: input integer ( int64 ) :: hash hash = fnv_1a ( FNV_OFFSET_32 , input ) end function fnv_1a_int64_scalar !> Hash a single 64bit integer with a starting seed pure function fnv_1a_int64_scalar_seed ( seed , input ) result ( hash ) integer ( int64 ), intent ( in ) :: seed integer ( int64 ), intent ( in ) :: input integer ( int64 ) :: hash character ( len = 8 , kind = c_char ) :: chars chars = transfer ( input , chars ) hash = fnv_1a ( seed , chars ) end function fnv_1a_int64_scalar_seed !> Hash a 1D array of 64bit integers pure function fnv_1a_int64_1d ( input ) result ( hash ) integer ( int64 ), intent ( in ) :: input (:) integer ( int64 ) :: hash hash = fnv_1a ( FNV_OFFSET_32 , input ) end function fnv_1a_int64_1d !> Hash a 1D array of 64bit integers with a starting seed pure function fnv_1a_int64_1d_seed ( seed , input ) result ( hash ) integer ( int64 ), intent ( in ) :: seed integer ( int64 ), intent ( in ) :: input (:) integer ( int64 ) :: hash integer :: i hash = seed do i = 1 , size ( input ) hash = fnv_1a ( hash , input ( i )) end do end function fnv_1a_int64_1d_seed !> Help fcn to convert hash to hex representation function hash_string ( hash_value ) result ( str ) integer ( int64 ), intent ( in ) :: hash_value character (:), allocatable :: str allocate ( character ( len = 10 ) :: str ) write ( str , '(Z0)' ) int ( hash_value , int32 ) end function hash_string end module fhash_fnv","tags":"","loc":"sourcefile/fhash_fnv.f90.html"},{"title":"fhash_tbl_iter.f90 – fhash API Reference","text":"Contents Modules fhash_tbl_iter Source Code fhash_tbl_iter.f90 Source Code module fhash_tbl_iter use fhash_tbl , only : fhash_tbl_t use fhash_key_base , only : fhash_key_t use fhash_data_container , only : fhash_container_t use fhash_sll implicit none private public fhash_iter_t !> Iterator type for iterating over hash table items type fhash_iter_t type ( fhash_tbl_t ), pointer :: tbl => NULL () integer :: bucket = 1 integer :: depth = 1 contains procedure :: next => fhash_iter_next procedure :: reset => fhash_iter_reset end type fhash_iter_t interface fhash_iter_t module procedure :: fhash_iter_init end interface fhash_iter_t contains !> Initialise fhash iterator function fhash_iter_init ( tbl ) result ( iter ) type ( fhash_tbl_t ), intent ( in ), target :: tbl type ( fhash_iter_t ) :: iter iter % tbl => tbl end function fhash_iter_init !> Return next item from iterator function fhash_iter_next ( iter , key , data ) result ( found ) class ( fhash_iter_t ), intent ( inout ) :: iter class ( fhash_key_t ), intent ( out ), allocatable :: key class ( * ), allocatable , intent ( out ) :: data logical :: found type ( fhash_container_t ), pointer :: data_container class ( * ), pointer :: data_out found = . false . if (. not . associated ( iter % tbl )) return do while (. not . found ) if ( iter % bucket > size ( iter % tbl % buckets )) return if (. not . allocated ( iter % tbl % buckets ( iter % bucket )% key )) then iter % bucket = iter % bucket + 1 cycle end if call sll_get_at ( iter % tbl % buckets ( iter % bucket ), iter % depth , key , data_container , found ) if ( iter % depth > node_depth ( iter % tbl % buckets ( iter % bucket ))) then iter % bucket = iter % bucket + 1 iter % depth = 1 else iter % depth = iter % depth + 1 end if end do if ( found ) then call data_container % get ( raw = data ) ! Extract underlying polymorphic data end if end function fhash_iter_next !> Reset iterator to beginning subroutine fhash_iter_reset ( iter ) class ( fhash_iter_t ), intent ( inout ) :: iter iter % bucket = 1 iter % depth = 1 end subroutine fhash_iter_reset end module fhash_tbl_iter","tags":"","loc":"sourcefile/fhash_tbl_iter.f90.html"},{"title":"fhash_tbl.f90 – fhash API Reference","text":"Contents Modules fhash_tbl Source Code fhash_tbl.f90 Source Code module fhash_tbl use iso_fortran_env , only : int32 , int64 , sp => real32 , dp => real64 use fhash_data_container , only : fhash_container use fhash_sll implicit none private public fhash_tbl_t !> This condition should be unreachable by the public interface integer , parameter , public :: FHASH_INTERNAL_ERROR = - 4 !> Error flag for operating on an unallocated table integer , parameter , public :: FHASH_EMPTY_TABLE = - 3 !> Error flag for when retrieved data-type does not !>  match that expected by the invoked getter function !>  (`get_int32`,`get_int63`,`get_float`,'get_double`,`get_char`) integer , parameter , public :: FHASH_FOUND_WRONG_TYPE = - 2 !> Error flag for when specified key is not found in the hash table integer , parameter , public :: FHASH_KEY_NOT_FOUND = - 1 !> Default allocation size integer , parameter :: FHASH_DEFAULT_ALLOCATION = 127 type fhash_tbl_t type ( fhash_node_t ), allocatable :: buckets (:) contains procedure :: allocate => fhash_tbl_allocate procedure :: unset => fhash_tbl_unset procedure :: check_key => fhash_tbl_check_key procedure :: stats => fhash_tbl_stats procedure :: fhash_tbl_set_scalar generic :: set => fhash_tbl_set_scalar procedure :: fhash_tbl_set_scalar_ptr generic :: set_ptr => fhash_tbl_set_scalar_ptr procedure :: fhash_tbl_get_int32 , fhash_tbl_get_int64 procedure :: fhash_tbl_get_float , fhash_tbl_get_double procedure :: fhash_tbl_get_char , fhash_tbl_get_logical procedure :: fhash_tbl_get_data , fhash_tbl_get_raw generic :: get => fhash_tbl_get_int32 , fhash_tbl_get_int64 generic :: get => fhash_tbl_get_float , fhash_tbl_get_double generic :: get => fhash_tbl_get_char , fhash_tbl_get_logical generic :: get => fhash_tbl_get_data generic :: get_raw => fhash_tbl_get_raw procedure :: fhash_tbl_get_int32_ptr , fhash_tbl_get_int64_ptr procedure :: fhash_tbl_get_float_ptr , fhash_tbl_get_double_ptr procedure :: fhash_tbl_get_char_ptr , fhash_tbl_get_logical_ptr procedure :: fhash_tbl_get_raw_ptr generic :: get_ptr => fhash_tbl_get_int32_ptr , fhash_tbl_get_int64_ptr generic :: get_ptr => fhash_tbl_get_float_ptr , fhash_tbl_get_double_ptr generic :: get_ptr => fhash_tbl_get_char_ptr , fhash_tbl_get_logical_ptr generic :: get_raw_ptr => fhash_tbl_get_raw_ptr final :: fhash_tbl_cleanup end type fhash_tbl_t contains !> Allocate hash table subroutine fhash_tbl_allocate ( tbl , size ) !> Table object to allocate class ( fhash_tbl_t ), intent ( inout ) :: tbl !> Number of buckets in hash table !> If ommited, `tbl` is allocated with `FHASH_DEFAULT_ALLOCATION` integer , intent ( in ), optional :: size if ( present ( size )) then allocate ( tbl % buckets ( size )) else allocate ( tbl % buckets ( FHASH_DEFAULT_ALLOCATION )) end if end subroutine fhash_tbl_allocate !> Finalizer for fhash_tbl_t subroutine fhash_tbl_cleanup ( tbl ) !> Table object to allocate type ( fhash_tbl_t ), intent ( inout ) :: tbl integer :: i if (. not . allocated ( tbl % buckets )) return do i = 1 , size ( tbl % buckets ) call sll_clean ( tbl % buckets ( i )) end do end subroutine fhash_tbl_cleanup !> Unset a value in the table !> subroutine fhash_tbl_unset ( tbl , key , stat ) !> Hash table object class ( fhash_tbl_t ), intent ( inout ) :: tbl !> Key to remove class ( fhash_key_t ), intent ( in ) :: key !> Status flag. Zero if successful. !> Unsuccessful: FHASH_EMPTY_TABLE | `FHASH_KEY_NOT_FOUND` integer , intent ( out ), optional :: stat integer :: index logical :: found if ( present ( stat )) stat = 0 if (. not . allocated ( tbl % buckets )) then if ( present ( stat )) stat = FHASH_EMPTY_TABLE return end if index = modulo ( key % hash (), size ( tbl % buckets , kind = int64 )) + 1 call sll_remove ( tbl % buckets ( index ), key , found ) if ( present ( stat )) stat = merge ( 0 , FHASH_KEY_NOT_FOUND , found ) end subroutine fhash_tbl_unset !> Check if key exists in table subroutine fhash_tbl_check_key ( tbl , key , stat ) !> Hash table object class ( fhash_tbl_t ), intent ( in ) :: tbl !> Key to retrieve class ( fhash_key_t ), intent ( in ) :: key !> Status flag. Zero if key is found. !> Unsuccessful: `FHASH_EMPTY_TABLE` | `FHASH_KEY_NOT_FOUND` integer , intent ( out ) :: stat integer :: index logical :: found type ( fhash_container_t ), pointer :: data if (. not . allocated ( tbl % buckets )) then stat = FHASH_EMPTY_TABLE return end if stat = 0 index = modulo ( key % hash (), size ( tbl % buckets , kind = int64 )) + 1 call sll_find_in ( tbl % buckets ( index ), key , data , found ) stat = merge ( 0 , FHASH_KEY_NOT_FOUND , found ) return end subroutine fhash_tbl_check_key !> Get stats about the hash table subroutine fhash_tbl_stats ( tbl , num_buckets , num_items , num_collisions , max_depth ) !> Hash table object class ( fhash_tbl_t ), intent ( in ) :: tbl !> Number of buckets allocated in table integer , intent ( out ), optional :: num_buckets !> Number of key-value pairs stored in table integer , intent ( out ), optional :: num_items !> Number of hash collisions integer , intent ( out ), optional :: num_collisions !> Maximum depth of bucket in table integer , intent ( out ), optional :: max_depth integer :: i , depth ! Initialise stats if ( present ( num_items )) num_items = 0 if ( present ( num_collisions )) num_collisions = 0 if ( present ( max_depth )) max_depth = 0 if ( present ( num_buckets )) num_buckets = 0 if (. not . allocated ( tbl % buckets )) return if ( present ( num_buckets )) then num_buckets = size ( tbl % buckets ) end if do i = 1 , size ( tbl % buckets ) depth = node_depth ( tbl % buckets ( i )) if ( present ( num_items )) num_items = num_items + depth if ( present ( num_collisions )) num_collisions = num_collisions + & merge ( depth - 1 , 0 , depth > 1 ) if ( present ( max_depth )) max_depth = max ( max_depth , depth ) end do end subroutine fhash_tbl_stats !> Set/update a polymorphic scalar value in the table !> !> `tbl` is allocated with default size if not already allocated subroutine fhash_tbl_set_scalar ( tbl , key , value , pointer ) !> Hash table object class ( fhash_tbl_t ), intent ( inout ) :: tbl !> Key to set/update class ( fhash_key_t ), intent ( in ) :: key !> Value for key class ( * ), intent ( in ), target :: value !> If .true., store a pointer to value instead of copying logical , intent ( in ), optional :: pointer integer :: index if (. not . allocated ( tbl % buckets )) call fhash_tbl_allocate ( tbl ) index = modulo ( key % hash (), size ( tbl % buckets , kind = int64 )) + 1 call sll_push_node ( tbl % buckets ( index ), key , value , pointer ) end subroutine fhash_tbl_set_scalar !> Get wrapper routine for generic 'set_ptr' !> !> `tbl` is allocated with default size if not already allocated subroutine fhash_tbl_set_scalar_ptr ( tbl , key , value ) !> Hash table object class ( fhash_tbl_t ), intent ( inout ) :: tbl !> Key to set/update class ( fhash_key_t ), intent ( in ) :: key !> Value for key class ( * ), intent ( in ), target :: value call fhash_tbl_set_scalar ( tbl , key , value , pointer = . true .) end subroutine fhash_tbl_set_scalar_ptr !> Retrieve data container from the hash table subroutine fhash_tbl_get_data ( tbl , key , data , stat ) !> Hash table object class ( fhash_tbl_t ), intent ( in ) :: tbl !> Key to retrieve class ( fhash_key_t ), intent ( in ) :: key !> Copy of value retrieved for key type ( fhash_container_t ), pointer :: data !> Status flag. Zero if successful. !> Unsuccessful: `FHASH_EMPTY_TABLE` | `FHASH_KEY_NOT_FOUND` integer , intent ( out ), optional :: stat integer :: index logical :: found if (. not . allocated ( tbl % buckets )) then if ( present ( stat )) stat = FHASH_EMPTY_TABLE return end if if ( present ( stat )) stat = 0 index = modulo ( key % hash (), size ( tbl % buckets , kind = int64 )) + 1 call sll_find_in ( tbl % buckets ( index ), key , data , found ) if (. not . found ) then if ( present ( stat )) stat = FHASH_KEY_NOT_FOUND return end if end subroutine fhash_tbl_get_data !> Get wrapper to retrieve a scalar intrinsic type value subroutine fhash_tbl_get_intrinsic_scalar ( tbl , key , i32 , i64 , r32 , r64 , char , raw , bool , stat ) !> Hash table object class ( fhash_tbl_t ), intent ( in ) :: tbl !> Key to retrieve class ( fhash_key_t ), intent ( in ) :: key !> Value to retrieve integer ( int32 ), intent ( out ), optional :: i32 integer ( int64 ), intent ( out ), optional :: i64 real ( sp ), intent ( out ), optional :: r32 real ( dp ), intent ( out ), optional :: r64 character (:), allocatable , intent ( out ), optional :: char logical , intent ( out ), optional :: bool class ( * ), allocatable , intent ( out ), optional :: raw !> Status flag. Zero if successful. !> Unsuccessful: `FHASH_EMPTY_TABLE` | !>  `FHASH_FOUND_WRONG_TYPE` | `FHASH_KEY_NOT_FOUND` integer , intent ( out ), optional :: stat logical :: type_match integer :: local_stat type ( fhash_container_t ), pointer :: data character (:), allocatable :: char_temp if ( present ( stat )) stat = 0 call fhash_tbl_get_data ( tbl , key , data , local_stat ) if ( local_stat /= 0 ) then if ( present ( stat )) stat = local_stat return end if if ( present ( char )) then ! (Work-around for weird gfortran bug re char dummy) call data % get ( i32 , i64 , r32 , r64 , char_temp , bool , raw , type_match ) if ( type_match ) char = char_temp else call data % get ( i32 , i64 , r32 , r64 , bool = bool , raw = raw , match = type_match ) end if if (. not . type_match ) then if ( present ( stat )) stat = FHASH_FOUND_WRONG_TYPE return end if end subroutine fhash_tbl_get_intrinsic_scalar !> Get wrapper to retrieve a scalar intrinsic type pointer subroutine fhash_tbl_get_intrinsic_scalar_ptr ( tbl , key , i32 , i64 , r32 , r64 , char , bool , raw , stat ) !> Hash table object class ( fhash_tbl_t ), intent ( in ) :: tbl !> Key to retrieve class ( fhash_key_t ), intent ( in ) :: key !> Value to retrieve integer ( int32 ), pointer , intent ( out ), optional :: i32 integer ( int64 ), pointer , intent ( out ), optional :: i64 real ( sp ), pointer , intent ( out ), optional :: r32 real ( dp ), pointer , intent ( out ), optional :: r64 character (:), pointer , intent ( out ), optional :: char logical , pointer , intent ( out ), optional :: bool class ( * ), pointer , intent ( out ), optional :: raw !> Status flag. Zero if successful. !> Unsuccessful: `FHASH_EMPTY_TABLE` | !>  `FHASH_FOUND_WRONG_TYPE` | `FHASH_KEY_NOT_FOUND` integer , intent ( out ), optional :: stat logical :: type_match integer :: local_stat type ( fhash_container_t ), pointer :: data character (:), pointer :: char_temp if ( present ( stat )) stat = 0 call fhash_tbl_get_data ( tbl , key , data , local_stat ) if ( local_stat /= 0 ) then if ( present ( stat )) stat = local_stat return end if if ( present ( char )) then ! (Work-around for weird gfortran bug re char dummy) call data % get_ptr ( i32 , i64 , r32 , r64 , char_temp , bool , raw , type_match ) if ( type_match ) char => char_temp else call data % get_ptr ( i32 , i64 , r32 , r64 , bool = bool , raw = raw , match = type_match ) end if if (. not . type_match ) then if ( present ( stat )) stat = FHASH_FOUND_WRONG_TYPE return end if end subroutine fhash_tbl_get_intrinsic_scalar_ptr !> Get wrapper to directly retrieve a scalar int32 value subroutine fhash_tbl_get_int32 ( tbl , key , value , stat ) class ( fhash_tbl_t ), intent ( in ) :: tbl !! Hash table object class ( fhash_key_t ), intent ( in ) :: key !! Key to retrieve integer ( int32 ), intent ( out ) :: value !! Output value integer , intent ( out ), optional :: stat !! Status flag. Zero if successful. call fhash_tbl_get_intrinsic_scalar ( tbl , key , i32 = value , stat = stat ) end subroutine fhash_tbl_get_int32 !> Get wrapper to directly retrieve a scalar int64 value subroutine fhash_tbl_get_int64 ( tbl , key , value , stat ) class ( fhash_tbl_t ), intent ( in ) :: tbl !! Hash table object class ( fhash_key_t ), intent ( in ) :: key !! Key to retrieve integer ( int64 ), intent ( out ) :: value !! Output value integer , intent ( out ), optional :: stat !! Status flag. Zero if successful. call fhash_tbl_get_intrinsic_scalar ( tbl , key , i64 = value , stat = stat ) end subroutine fhash_tbl_get_int64 !> Get wrapper to directly retrieve a scalar float value subroutine fhash_tbl_get_float ( tbl , key , value , stat ) class ( fhash_tbl_t ), intent ( in ) :: tbl !! Hash table object class ( fhash_key_t ), intent ( in ) :: key !! Key to retrieve real ( sp ), intent ( out ) :: value !! Output value integer , intent ( out ), optional :: stat !! Status flag. Zero if successful. call fhash_tbl_get_intrinsic_scalar ( tbl , key , r32 = value , stat = stat ) end subroutine fhash_tbl_get_float !> Get wrapper to directly retrieve a scalar double value subroutine fhash_tbl_get_double ( tbl , key , value , stat ) class ( fhash_tbl_t ), intent ( in ) :: tbl !! Hash table object class ( fhash_key_t ), intent ( in ) :: key !! Key to retrieve real ( dp ), intent ( out ) :: value !! Output value integer , intent ( out ), optional :: stat !! Status flag. Zero if successful. call fhash_tbl_get_intrinsic_scalar ( tbl , key , r64 = value , stat = stat ) end subroutine fhash_tbl_get_double !> Get wrapper to directly retrieve a scalar character value subroutine fhash_tbl_get_char ( tbl , key , value , stat ) class ( fhash_tbl_t ), intent ( in ) :: tbl !! Hash table object class ( fhash_key_t ), intent ( in ) :: key !! Key to retrieve character (:), allocatable , intent ( out ) :: value !! Output value integer , intent ( out ), optional :: stat !! Status flag. Zero if successful. call fhash_tbl_get_intrinsic_scalar ( tbl , key , char = value , stat = stat ) end subroutine fhash_tbl_get_char !> Get wrapper to directly retrieve a scalar logical value subroutine fhash_tbl_get_logical ( tbl , key , value , stat ) class ( fhash_tbl_t ), intent ( in ) :: tbl !! Hash table object class ( fhash_key_t ), intent ( in ) :: key !! Key to retrieve logical , intent ( out ) :: value !! Output value integer , intent ( out ), optional :: stat !! Status flag. Zero if successful. call fhash_tbl_get_intrinsic_scalar ( tbl , key , bool = value , stat = stat ) end subroutine fhash_tbl_get_logical !> Get wrapper to directly retrieve underlying polymorhpic scalar value subroutine fhash_tbl_get_raw ( tbl , key , value , stat ) class ( fhash_tbl_t ), intent ( in ) :: tbl !! Hash table object class ( fhash_key_t ), intent ( in ) :: key !! Key to retrieve class ( * ), allocatable , intent ( out ) :: value !! Output value integer , intent ( out ), optional :: stat !! Status flag. Zero if successful. call fhash_tbl_get_intrinsic_scalar ( tbl , key , raw = value , stat = stat ) end subroutine fhash_tbl_get_raw !> Get wrapper to directly retrieve a scalar int32 value subroutine fhash_tbl_get_int32_ptr ( tbl , key , value , stat ) class ( fhash_tbl_t ), intent ( in ) :: tbl !! Hash table object class ( fhash_key_t ), intent ( in ) :: key !! Key to retrieve integer ( int32 ), pointer , intent ( out ) :: value !! Output value pointer integer , intent ( out ), optional :: stat !! Status flag. Zero if successful. call fhash_tbl_get_intrinsic_scalar_ptr ( tbl , key , i32 = value , stat = stat ) end subroutine fhash_tbl_get_int32_ptr !> Get wrapper to directly retrieve a scalar int64 value subroutine fhash_tbl_get_int64_ptr ( tbl , key , value , stat ) class ( fhash_tbl_t ), intent ( in ) :: tbl !! Hash table object class ( fhash_key_t ), intent ( in ) :: key !! Key to retrieve integer ( int64 ), pointer , intent ( out ) :: value !! Output value pointer integer , intent ( out ), optional :: stat !! Status flag. Zero if successful. call fhash_tbl_get_intrinsic_scalar_ptr ( tbl , key , i64 = value , stat = stat ) end subroutine fhash_tbl_get_int64_ptr !> Get wrapper to directly retrieve a scalar float value subroutine fhash_tbl_get_float_ptr ( tbl , key , value , stat ) class ( fhash_tbl_t ), intent ( in ) :: tbl !! Hash table object class ( fhash_key_t ), intent ( in ) :: key !! Key to retrieve real ( sp ), pointer , intent ( out ) :: value !! Output value pointer integer , intent ( out ), optional :: stat !! Status flag. Zero if successful. call fhash_tbl_get_intrinsic_scalar_ptr ( tbl , key , r32 = value , stat = stat ) end subroutine fhash_tbl_get_float_ptr !> Get wrapper to directly retrieve a scalar double value subroutine fhash_tbl_get_double_ptr ( tbl , key , value , stat ) class ( fhash_tbl_t ), intent ( in ) :: tbl !! Hash table object class ( fhash_key_t ), intent ( in ) :: key !! Key to retrieve real ( dp ), pointer , intent ( out ) :: value !! Output value pointer integer , intent ( out ), optional :: stat !! Status flag. Zero if successful. call fhash_tbl_get_intrinsic_scalar_ptr ( tbl , key , r64 = value , stat = stat ) end subroutine fhash_tbl_get_double_ptr !> Get wrapper to directly retrieve a scalar character value subroutine fhash_tbl_get_char_ptr ( tbl , key , value , stat ) class ( fhash_tbl_t ), intent ( in ) :: tbl !! Hash table object class ( fhash_key_t ), intent ( in ) :: key !! Key to retrieve character (:), pointer , intent ( out ) :: value !! Output value pointer integer , intent ( out ), optional :: stat !! Status flag. Zero if successful. call fhash_tbl_get_intrinsic_scalar_ptr ( tbl , key , char = value , stat = stat ) end subroutine fhash_tbl_get_char_ptr !> Get wrapper to directly retrieve a scalar logical value subroutine fhash_tbl_get_logical_ptr ( tbl , key , value , stat ) class ( fhash_tbl_t ), intent ( in ) :: tbl !! Hash table object class ( fhash_key_t ), intent ( in ) :: key !! Key to retrieve logical , pointer , intent ( out ) :: value !! Output value pointer integer , intent ( out ), optional :: stat !! Status flag. Zero if successful. call fhash_tbl_get_intrinsic_scalar_ptr ( tbl , key , bool = value , stat = stat ) end subroutine fhash_tbl_get_logical_ptr !> Get wrapper to directly retrieve underlying polymorhpic scalar value subroutine fhash_tbl_get_raw_ptr ( tbl , key , value , stat ) class ( fhash_tbl_t ), intent ( in ) :: tbl !! Hash table object class ( fhash_key_t ), intent ( in ) :: key !! Key to retrieve class ( * ), pointer , intent ( out ) :: value !! Output value integer , intent ( out ), optional :: stat !! Status flag. Zero if successful. call fhash_tbl_get_intrinsic_scalar_ptr ( tbl , key , raw = value , stat = stat ) end subroutine fhash_tbl_get_raw_ptr end module fhash_tbl","tags":"","loc":"sourcefile/fhash_tbl.f90.html"},{"title":"fhash.f90 – fhash API Reference","text":"Contents Modules fhash Source Code fhash.f90 Source Code module fhash use fhash_tbl , only : fhash_tbl_t use fhash_tbl_iter , only : fhash_iter_t use fhash_key_base , only : fhash_key_t use fhash_key_char , only : fhash_key_char_t , fhash_key use fhash_key_int32 , only : fhash_key_int32_t , fhash_key use fhash_key_int64 , only : fhash_key_int64_t , fhash_key use fhash_key_int32_1d , only : fhash_key_int32_1d_t , fhash_key use fhash_key_int64_1d , only : fhash_key_int64_1d_t , fhash_key implicit none end module fhash","tags":"","loc":"sourcefile/fhash.f90.html"},{"title":"char.f90 – fhash API Reference","text":"Contents Modules fhash_key_char Source Code char.f90 Source Code !> Implements a concrete type for scalar int32 hash keys !> module fhash_key_char use iso_fortran_env , only : int32 , int64 use fhash_key_base , only : fhash_key_t use fhash_fnv , only : fnv_1a implicit none private public fhash_key_char_t public fhash_key !> Hash table key container type , extends ( fhash_key_t ) :: fhash_key_char_t private character (:), allocatable :: value contains procedure , pass :: hash => key_hash_char procedure , pass :: equals => key_equal_char procedure , pass :: to_string => key_char_to_string end type fhash_key_char_t interface fhash_key module procedure :: key_from_char end interface fhash_key contains !> Check if two keys are equal pure function key_equal_char ( key1 , key2 ) result ( keys_equal ) class ( fhash_key_char_t ), intent ( in ) :: key1 class ( fhash_key_t ), intent ( in ) :: key2 logical :: keys_equal keys_equal = . false . select type ( k2 => key2 ) type is ( fhash_key_char_t ) if ( allocated ( key1 % value ) . and . allocated ( k2 % value )) then if ( key1 % value == k2 % value ) then keys_equal = . true . return end if end if end select end function key_equal_char !> Generate hash of key pure function key_hash_char ( key ) result ( hash ) class ( fhash_key_char_t ), intent ( in ) :: key integer ( int64 ) :: hash hash = fnv_1a ( key % value ) end function key_hash_char !> Generate string representation of hash function key_char_to_string ( key ) result ( str ) class ( fhash_key_char_t ), intent ( in ) :: key character (:), allocatable :: str str = key % value end function key_char_to_string !> Create new key container from a scalar int32 function key_from_char ( source ) result ( key ) character ( * ), intent ( in ) :: source type ( fhash_key_char_t ) :: key key % value = source end function key_from_char end module fhash_key_char","tags":"","loc":"sourcefile/char.f90.html"},{"title":"base.f90 – fhash API Reference","text":"Contents Modules fhash_key_base Source Code base.f90 Source Code !> Implements an abstract type for hash keys !> module fhash_key_base use iso_fortran_env , only : int32 , int64 implicit none private public fhash_key_t !> Abstract base type for defining hash keys type , abstract :: fhash_key_t contains procedure ( hash_proc ), deferred :: hash procedure ( equality_proc ), deferred :: equals procedure ( to_string_proc ), deferred :: to_string generic , public :: operator ( == ) => equals end type fhash_key_t abstract interface pure function equality_proc ( key1 , key2 ) result ( keys_equal ) import class ( fhash_key_t ), intent ( in ) :: key1 class ( fhash_key_t ), intent ( in ) :: key2 logical :: keys_equal end function equality_proc pure function hash_proc ( key ) result ( hash ) import class ( fhash_key_t ), intent ( in ) :: key integer ( int64 ) :: hash end function hash_proc function to_string_proc ( key ) result ( str ) import class ( fhash_key_t ), intent ( in ) :: key character (:), allocatable :: str end function to_string_proc end interface end module fhash_key_base","tags":"","loc":"sourcefile/base.f90.html"},{"title":"int64_1d.f90 – fhash API Reference","text":"Contents Modules fhash_key_int64_1d Source Code int64_1d.f90 Source Code !> Implements a concrete type for 1D int64 array hash keys !> module fhash_key_int64_1d use iso_fortran_env , only : int64 use fhash_key_base , only : fhash_key_t use fhash_fnv , only : fnv_1a implicit none private public fhash_key_int64_1d_t public fhash_key !> Hash table key container type , extends ( fhash_key_t ) :: fhash_key_int64_1d_t private integer ( int64 ), allocatable :: value (:) contains procedure , pass :: hash => key_hash_int64_1d procedure , pass :: equals => key_equal_int64_1d procedure , pass :: to_string => key_int64_1d_to_string end type fhash_key_int64_1d_t interface fhash_key module procedure :: key_from_int64_1d end interface fhash_key contains !> Check if two keys are equal pure function key_equal_int64_1d ( key1 , key2 ) result ( keys_equal ) class ( fhash_key_int64_1d_t ), intent ( in ) :: key1 class ( fhash_key_t ), intent ( in ) :: key2 logical :: keys_equal keys_equal = . false . select type ( k2 => key2 ) type is ( fhash_key_int64_1d_t ) if (. not .( allocated ( key1 % value ) . and . allocated ( k2 % value ))) then return end if if ( size ( key1 % value ) /= size ( k2 % value )) then return end if if ( all ( key1 % value == k2 % value )) then keys_equal = . true . return end if end select end function key_equal_int64_1d !> Generate hash of key pure function key_hash_int64_1d ( key ) result ( hash ) class ( fhash_key_int64_1d_t ), intent ( in ) :: key integer ( int64 ) :: hash hash = fnv_1a ( key % value ) end function key_hash_int64_1d !> Generate string representation of hash pure function key_int64_1d_to_string ( key ) result ( str ) class ( fhash_key_int64_1d_t ), intent ( in ) :: key character (:), allocatable :: str allocate ( character ( 1024 ) :: str ) write ( str , * ) key % value str = trim ( str ) end function key_int64_1d_to_string !> Create new key container from a scalar int64 function key_from_int64_1d ( source ) result ( key ) integer ( int64 ), intent ( in ) :: source (:) type ( fhash_key_int64_1d_t ) :: key key % value = source end function key_from_int64_1d end module fhash_key_int64_1d","tags":"","loc":"sourcefile/int64_1d.f90.html"},{"title":"int64.f90 – fhash API Reference","text":"Contents Modules fhash_key_int64 Source Code int64.f90 Source Code !> Implements a concrete type for scalar int64 hash keys !> module fhash_key_int64 use iso_fortran_env , only : int64 use fhash_key_base , only : fhash_key_t use fhash_fnv , only : fnv_1a implicit none private public fhash_key_int64_t public fhash_key !> Hash table key container type , extends ( fhash_key_t ) :: fhash_key_int64_t private integer ( int64 ) :: value contains procedure , pass :: hash => key_hash_int64 procedure , pass :: equals => key_equal_int64 procedure , pass :: to_string => key_int64_to_string end type fhash_key_int64_t interface fhash_key module procedure :: key_from_int64 end interface fhash_key contains !> Check if two keys are equal pure function key_equal_int64 ( key1 , key2 ) result ( keys_equal ) class ( fhash_key_int64_t ), intent ( in ) :: key1 class ( fhash_key_t ), intent ( in ) :: key2 logical :: keys_equal keys_equal = . false . select type ( k2 => key2 ) type is ( fhash_key_int64_t ) if ( key1 % value == k2 % value ) then keys_equal = . true . return end if end select end function key_equal_int64 !> Generate hash of key pure function key_hash_int64 ( key ) result ( hash ) class ( fhash_key_int64_t ), intent ( in ) :: key integer ( int64 ) :: hash hash = fnv_1a ( key % value ) end function key_hash_int64 !> Generate string representation of hash pure function key_int64_to_string ( key ) result ( str ) class ( fhash_key_int64_t ), intent ( in ) :: key character (:), allocatable :: str allocate ( character ( 1024 ) :: str ) write ( str , * ) key % value str = trim ( str ) end function key_int64_to_string !> Create new key container from a scalar int64 function key_from_int64 ( source ) result ( key ) integer ( int64 ), intent ( in ) :: source type ( fhash_key_int64_t ) :: key key % value = source end function key_from_int64 end module fhash_key_int64","tags":"","loc":"sourcefile/int64.f90.html"},{"title":"int32.f90 – fhash API Reference","text":"Contents Modules fhash_key_int32 Source Code int32.f90 Source Code !> Implements a concrete type for scalar int32 hash keys !> module fhash_key_int32 use iso_fortran_env , only : int32 , int64 use fhash_key_base , only : fhash_key_t use fhash_fnv , only : fnv_1a implicit none private public fhash_key_int32_t public fhash_key !> Hash table key container type , extends ( fhash_key_t ) :: fhash_key_int32_t private integer ( int32 ) :: value contains procedure , pass :: hash => key_hash_int32 procedure , pass :: equals => key_equal_int32 procedure , pass :: to_string => key_int32_to_string end type fhash_key_int32_t interface fhash_key module procedure :: key_from_int32 end interface fhash_key contains !> Check if two keys are equal pure function key_equal_int32 ( key1 , key2 ) result ( keys_equal ) class ( fhash_key_int32_t ), intent ( in ) :: key1 class ( fhash_key_t ), intent ( in ) :: key2 logical :: keys_equal keys_equal = . false . select type ( k2 => key2 ) type is ( fhash_key_int32_t ) if ( key1 % value == k2 % value ) then keys_equal = . true . return end if end select end function key_equal_int32 !> Generate hash of key pure function key_hash_int32 ( key ) result ( hash ) class ( fhash_key_int32_t ), intent ( in ) :: key integer ( int64 ) :: hash hash = fnv_1a ( key % value ) end function key_hash_int32 !> Generate string representation of hash pure function key_int32_to_string ( key ) result ( str ) class ( fhash_key_int32_t ), intent ( in ) :: key character (:), allocatable :: str allocate ( character ( 1024 ) :: str ) write ( str , * ) key % value str = trim ( str ) end function key_int32_to_string !> Create new key container from a scalar int32 function key_from_int32 ( source ) result ( key ) integer ( int32 ), intent ( in ) :: source type ( fhash_key_int32_t ) :: key key % value = source end function key_from_int32 end module fhash_key_int32","tags":"","loc":"sourcefile/int32.f90.html"},{"title":"int32_1d.f90 – fhash API Reference","text":"Contents Modules fhash_key_int32_1d Source Code int32_1d.f90 Source Code !> Implements a concrete type for 1D int32 array hash keys !> module fhash_key_int32_1d use iso_fortran_env , only : int32 , int64 use fhash_key_base , only : fhash_key_t use fhash_fnv , only : fnv_1a implicit none private public fhash_key_int32_1d_t public fhash_key !> Hash table key container type , extends ( fhash_key_t ) :: fhash_key_int32_1d_t private integer ( int32 ), allocatable :: value (:) contains procedure , pass :: hash => key_hash_int32_1d procedure , pass :: equals => key_equal_int32_1d procedure , pass :: to_string => key_int32_1d_to_string end type fhash_key_int32_1d_t interface fhash_key module procedure :: key_from_int32_1d end interface fhash_key contains !> Check if two keys are equal pure function key_equal_int32_1d ( key1 , key2 ) result ( keys_equal ) class ( fhash_key_int32_1d_t ), intent ( in ) :: key1 class ( fhash_key_t ), intent ( in ) :: key2 logical :: keys_equal keys_equal = . false . select type ( k2 => key2 ) type is ( fhash_key_int32_1d_t ) if (. not .( allocated ( key1 % value ) . and . allocated ( k2 % value ))) then return end if if ( size ( key1 % value ) /= size ( k2 % value )) then return end if if ( all ( key1 % value == k2 % value )) then keys_equal = . true . return end if end select end function key_equal_int32_1d !> Generate hash of key pure function key_hash_int32_1d ( key ) result ( hash ) class ( fhash_key_int32_1d_t ), intent ( in ) :: key integer ( int64 ) :: hash hash = fnv_1a ( key % value ) end function key_hash_int32_1d !> Generate string representation of hash pure function key_int32_1d_to_string ( key ) result ( str ) class ( fhash_key_int32_1d_t ), intent ( in ) :: key character (:), allocatable :: str allocate ( character ( 1024 ) :: str ) write ( str , * ) key % value str = trim ( str ) end function key_int32_1d_to_string !> Create new key container from a scalar int32 function key_from_int32_1d ( source ) result ( key ) integer ( int32 ), intent ( in ) :: source (:) type ( fhash_key_int32_1d_t ) :: key key % value = source end function key_from_int32_1d end module fhash_key_int32_1d","tags":"","loc":"sourcefile/int32_1d.f90.html"},{"title":"User Guide – fhash API Reference","text":"Basic usage The package provides a fhash_tbl_t type with set and get methods for storing and retrieving key-value pairs. e.g. Declare a table instance use fhash ... type ( fhash_tbl_t ) :: tbl The fhash_key interface A extensible interface for generating an instance of fhash_key_t needed to set and get key-value pairs. The library provides generic support for generating keys from scalar or 1D arrays of integers ( integer(int32) , integer(int64) ) or from scalar character(*) e.g. Create a key from a string use fhash , only : key => fhash_key ... key ( 'key_string' ) For how to extend the fhash_key_t interface to other types, see the custom key demo The set method Stores (or overwrites) a key-value pair into the hash table. Will accept any scalar variable as a value, including (scalar) derived types. e.g. Set key value pair use fhash , only : fhash_tbl_t , key => fhash_key ... type ( fhash_tbl_t ) :: tbl tbl % set ( key ( 'key' ), value = 1 ) To store a pointer instead of copying the value, use set_ptr . The get method A generic interface for retrieving intrinsic scalar values from the table. The library provides generic support for retrieving scalar values of the following types: integer(int32) , integer(int64) real(real32) , real(real64) character(*) logical e.g. Get integer value for a key use fhash , only : fhash_tbl_t , key => fhash_key ... type ( fhash_tbl_t ) :: tbl integer :: v tbl % get ( key ( 'key' ), value = v ) An optional integer stat argument may be passed which is non-zero on exit if the retrieval was unsuccessful. Non-zero return values may be one of: FHASH_KEY_NOT_FOUND , FHASH_FOUND_WRONG_TYPE , or FHASH_EMPTY_TABLE . For how to retrieve derived types see the derived type demo . To retrieve a pointer instead of copying the value, use get_ptr . A simple example program !> Example program demonstrating basic set/get usage !>  for different key/value types program fhash_demo use fhash , only : fhash_tbl_t , key => fhash_key implicit none type ( fhash_tbl_t ) :: tbl integer :: i real :: r character (:), allocatable :: char logical :: bool print * , '# fhash demo program: simple-demo' call tbl % set ( key ( 'my_key_1' ), value = 10 ) call tbl % set ( key ( 'my_key_2' ), value = 1.0 ) call tbl % set ( key ( 123456 ), value = 'a string value' ) call tbl % set ( key ([ 1 , 2 , 3 , 4 , 5 ]), value = . false .) call tbl % get ( key ( 'my_key_1' ), i ) call tbl % get ( key ( 'my_key_2' ), r ) call tbl % get ( key ( 123456 ), char ) call tbl % get ( key ([ 1 , 2 , 3 , 4 , 5 ]), bool ) print * , 'Key = \"my_key_1\"     Value = ' , i print * , 'Key = \"my_key_2\"     Value = ' , r print * , 'Key = 123456         Value = \"' , char , '\"' print * , 'Key = [1,2,3,4,5]    Value = ' , bool print * end program fhash_demo","tags":"","loc":"page/index.html"},{"title":"Hash table methods – fhash API Reference","text":"Hash table methods Other hash table methods, in addition to set and get , are: allocate : manually allocate the number of table buckets check_key : determine whether a given key exists within the table unset : remove a key-value pair from the table stats : query information about the table instance Example !> Example program demonstrating useful !>  fhash_tbl_t methods program fhash_demo use fhash , only : fhash_tbl_t , key => fhash_key implicit none type ( fhash_tbl_t ) :: tbl integer :: i , stat integer :: num_buckets , num_items , num_collisions , max_depth print * , '# fhash demo program: methods-demo' !> Manually specify number of table buckets call tbl % allocate ( 301 ) print * , 'Setting keys... ' do i = 0 , 256 call tbl % set ( key ( i ), i * i ) end do !> Query information about the hash table print * , 'Querying table info...' call tbl % stats ( num_buckets , num_items , num_collisions , max_depth ) write ( * , '(A,T40,I0)' ) '  Number of buckets allocated: ' , num_buckets write ( * , '(A,T40,I0)' ) '  Number of key-value pairs stored: ' , num_items write ( * , '(A,T40,I0)' ) '  Total number of hash-collisions: ' , num_collisions write ( * , '(A,T40,I0)' ) '  The worst case bucket depth is ' , max_depth print * !> Check for existence of a key call tbl % check_key ( key ( 0 ), stat ) print * , 'Check key 0: ' , merge ( 'FOUND    ' , 'NOT FOUND' , stat == 0 ) !> Unset a key in the table print * , 'Removing key 0...' call tbl % unset ( key ( 0 )) call tbl % check_key ( key ( 0 ), stat ) print * , 'Check key 0: ' , merge ( 'FOUND    ' , 'NOT FOUND' , stat == 0 ) print * end program fhash_demo","tags":"","loc":"page/1-methods-demo/index.html"},{"title":"Example: Custom value types – fhash API Reference","text":"Example: Custom value types Since an unlimited polymorphic argument is used when storing hash table\nvalues, no modification is required to set custom derived types as values. However, when retrieving values it is convenient to define a custom getter\nroutine to correctly obtain the derived type value from the table. In this demo, a custom getter is defined for a string_t type.\nThe getter must obtain a raw polymorphic allocatable from the hash table,\nand determine the type using the select type construct. The getter \nshould therefore implement some form of error handling for the case when\nthe requested key is not of the expected derived type. !> Example program demonstrating how to store and retrieve !>  custom derived types using `fhash` program fhash_demo use fhash , only : fhash_tbl_t , key => fhash_key , fhash_key_t implicit none type string_t character (:), allocatable :: s end type string_t type ( fhash_tbl_t ) :: tbl character (:), allocatable :: key_str type ( string_t ) :: str1 , str2 print * , '# fhash demo program: derived-type-demo' str1 % s = 'Hello fhash' key_str = 'my_key' print * , 'Storing value \"' , str1 % s , '\" with key: \"' , key_str , '\"' call tbl % set ( key ( key_str ), value = str1 ) print * , 'Retrieving value with key: \"' , key_str , '\"' call fhash_get_string ( tbl , key ( key_str ), str2 ) print * , '   value = \"' , str2 % s , '\"' print * contains !> Define custom getter for string_t type subroutine fhash_get_string ( tbl , k , string ) type ( fhash_tbl_t ), intent ( in ) :: tbl class ( fhash_key_t ), intent ( in ) :: k type ( string_t ), intent ( out ) :: string integer :: stat class ( * ), allocatable :: data call tbl % get_raw ( k , data , stat ) if ( stat /= 0 ) print * , 'error ' , stat ! Error handling: key not found select type ( d => data ) type is ( string_t ) string = d class default ! Error handling: found wrong type print * , 'error' end select end subroutine fhash_get_string end program fhash_demo","tags":"","loc":"page/2-derived-type-demo/index.html"},{"title":"Example: Custom key types – fhash API Reference","text":"Example: Custom Key Types Custom key types can be defined simply by extension of the abstract fhash_key_t type\ndefined in fhash_key_base .\nExtensions of this type must implement the equals , hash and to_string procedures.\nOptionally, you may also override the fhash_key interface with a helper function to\ngenerate a key from your custom type. To perform the hashing, the included fhash_fnv module provides the fnv_1a interface\nwhich supports default scalar characters and 32bit/64bit scalar/1D integers.\nYou can use this interface to generate a hash from the components of your derived type. In this example, a key_string_t key container type is defined as an extension\nof fhash_key_T which allows the string_t derived type to be used as a key. !> Example program demonstrating how a custom key-type !>  can be used. !> See the `my_key_type` module for the definition of the !>  custom key type. !> !> See README.md for an explanation !> program fhash_demo use fhash , only : fhash_tbl_t use my_key_type , only : string_t , key_string_t , key => fhash_key implicit none type ( fhash_tbl_t ) :: tbl type ( string_t ) :: str1 , str2 integer :: val print * , '# fhash demo program: custom-key-demo' str1 % s = 'Hello world' str2 % s = 'Hello fhash' print * , 'Storing value 10 with key: \"' , str1 % s , '\"' call tbl % set ( key ([ str1 ]), value = 10 ) print * , 'Storing value 20 with key: \"' , str2 % s , '\"' call tbl % set ( key ([ str2 ]), value = 20 ) print * , 'Storing value 30 with key: [\"' , str1 % s , '\", \"' , str2 % s , '\"]' call tbl % set ( key ([ str1 , str2 ]), value = 30 ) print * , 'Retrieving value with key: \"' , str1 % s , '\"' call tbl % get ( key ([ str1 ]), val ) print * , '   value = ' , val print * , 'Retrieving value with key: \"' , str2 % s , '\"' call tbl % get ( key ([ str2 ]), val ) print * , '   value = ' , val print * , 'Retrieving value with key: [\"' , str1 % s , '\", \"' , str2 % s , '\"]' call tbl % get ( key ([ str1 , str2 ]), val ) print * , '   value = ' , val print * end program fhash_demo","tags":"","loc":"page/3-custom-key-demo/index.html"},{"title":"Key implementation – fhash API Reference","text":"Custom key type implementation !> Example module demonstrating how a custom key-type !>  can be made. !> !> See README.md for an explanation !> module my_key_type use iso_fortran_env , only : int64 use fhash_key_base , only : fhash_key_t use fhash_fnv , only : fnv_1a implicit none private public :: string_t , key_string_t public :: fhash_key !> The custom type for which we wish to create a key type :: string_t character (:), allocatable :: s end type string_t !> A key type container for our custom type type , extends ( fhash_key_t ) :: key_string_t type ( string_t ), allocatable :: value (:) contains procedure :: hash => key_hash_string_t procedure :: equals => key_equals_string_t procedure , pass :: to_string => key_to_string end type key_string_t !> Override the existing `fhash_key` interface to additionally !>  support our custom key type interface fhash_key module procedure :: key_from_string_t end interface fhash_key contains !> Implements equality operator for custom key type. !> !> NB. Keys of different types are always not equal. !> pure function key_equals_string_t ( key1 , key2 ) result ( keys_equal ) class ( key_string_t ), intent ( in ) :: key1 class ( fhash_key_t ), intent ( in ) :: key2 logical :: keys_equal integer :: i keys_equal = . false . select type ( k2 => key2 ) type is ( key_string_t ) if ( size ( key1 % value ) /= size ( k2 % value )) return do i = 1 , size ( key1 % value ) if ( key1 % value ( i )% s /= k2 % value ( i )% s ) then return end if end do keys_equal = . true . return end select end function key_equals_string_t !> Implements hashing of the custom key type. !> !> NB. Elementary hash function `fnv_1a` provides support for !>  default scalar characters and 32bit/64bit scalar and 1D integers !> pure function key_hash_string_t ( key ) result ( hash ) class ( key_string_t ), intent ( in ) :: key integer ( int64 ) :: hash integer :: i do i = 1 , size ( key % value ) if ( i == 1 ) then hash = fnv_1a ( key % value ( i )% s ) else hash = fnv_1a ( hash , key % value ( i )% s ) end if end do end function key_hash_string_t !> Generate string representation of hash pure function key_to_string ( key ) result ( str ) class ( key_string_t ), intent ( in ) :: key character (:), allocatable :: str integer :: i str = '' do i = 1 , size ( key % value ) str = str // ',' // key % value ( i )% s end do end function key_to_string !> Helper function to create new key container from !>  some set of inputs function key_from_string_t ( source ) result ( key ) type ( string_t ), intent ( in ) :: source (:) type ( key_string_t ) :: key key % value = source end function key_from_string_t end module my_key_type","tags":"","loc":"page/3-custom-key-demo/key_implementation.html"},{"title":"Example: Iterating over hash table items – fhash API Reference","text":"!> Example program demonstrating how to iterate over items in hash table program fhash_demo use fhash , only : fhash_tbl_t , key => fhash_key , fhash_iter_t , fhash_key_t implicit none type ( fhash_tbl_t ) :: tbl type ( fhash_iter_t ) :: iter class ( fhash_key_t ), allocatable :: ikey class ( * ), allocatable :: idata print * , '# fhash demo program: iter-demo' call tbl % set ( key ( 'my_key_1' ), value = 10 ) call tbl % set ( key ( 'my_key_2' ), value = 1.0 ) call tbl % set ( key ( 123456 ), value = 'a string value' ) call tbl % set ( key ([ 1 , 2 , 3 , 4 , 5 ]), value = . false .) !> Iterate over all items in table iter = fhash_iter_t ( tbl ) do while ( iter % next ( ikey , idata )) write ( * , * ) 'Key = \"' // ikey % to_string () // '\"' call print_polymorphic ( idata ) end do ! call iter%reset()  ! (Reset if iterator needed again) contains !> Helper routine to print out polymorphic variable for intrinsics data types subroutine print_polymorphic ( data ) class ( * ), intent ( in ) :: data select type ( d => data ) type is ( integer ) write ( * , * ) d type is ( real ) write ( * , * ) d type is ( character ( * )) write ( * , * ) d type is ( logical ) write ( * , * ) d class default write ( * , * ) '[unknown data type, print not implemented]' end select end subroutine print_polymorphic end program fhash_demo","tags":"","loc":"page/4-iter-demo/index.html"}]}